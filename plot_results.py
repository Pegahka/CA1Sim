__author__ = 'milsteina'
from function_lib import *
import matplotlib.lines as mlines
import matplotlib as mpl
import numpy as np
import scipy.signal as signal

mpl.rcParams['svg.fonttype'] = 'none'
mpl.rcParams['font.size'] = 14.  # 18.
mpl.rcParams['font.sans-serif'] = 'Arial'
mpl.rcParams['text.usetex'] = False
"""
mpl.rcParams['axes.labelsize'] = 'larger'
mpl.rcParams['axes.titlesize'] = 'xx-large'
mpl.rcParams['xtick.labelsize'] = 'large'
mpl.rcParams['ytick.labelsize'] = 'large'
mpl.rcParams['legend.fontsize'] = 'x-large'
"""

def plot_AR(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_spine_attenuation_ratio.
    Files contain voltage recordings from spine and branch probed with EPSC-shaped current injections to measure spine
    to branch EPSP amplitude attenuation ratio, dendritic branch impedance, and spine neck resistance. Plots these
    parameters vs distance from dendrite origin, with one column per dendritic sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in [sim for sim in f.itervalues() if sim.attrs['stim_loc'] == 'spine']:
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    AR = {}
    dendR = {}
    neckR = {}
    fig, axes = plt.subplots(3, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        for sec_type in sec_types:
            distances[sec_type] = []
            AR[sec_type] = []
            dendR[sec_type] = []
            neckR[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0'].attrs['amp']
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                spine_tvec = f[indices['spine']]['time']
                branch_stim = f[indices['branch']]['rec']
                branch_tvec = f[indices['branch']]['time']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        branch_rec = rec
                        sec_type = rec.attrs['type']
                    elif rec.attrs['description'] == 'spine':
                        spine_rec = rec
                distances[sec_type].append(branch_rec.attrs['branch_distance'])
                interp_t = np.arange(0, duration, 0.001)
                interp_branch_vm = np.interp(interp_t, spine_tvec[:], branch_rec[:])
                interp_spine_vm = np.interp(interp_t, spine_tvec[:], spine_rec[:])
                left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(interp_branch_vm[left:right])
                baseline_spine = np.average(interp_spine_vm[left:right])
                left, right = time2index(interp_t, equilibrate, duration)
                peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                peak_spine = np.max(interp_spine_vm[left:right]) - baseline_spine
                this_AR = peak_spine / peak_branch
                AR[sec_type].append(this_AR)
                branch_rec = branch_stim['0'] if branch_stim['0'].attrs['description'] == 'branch' else branch_stim['1']
                interp_t = np.arange(0, duration, 0.001)
                interp_branch_vm = np.interp(interp_t, branch_tvec[:], branch_rec[:])
                left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(interp_branch_vm[left:right])
                left, right = time2index(interp_t, equilibrate, duration)
                peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                this_dendR = peak_branch / amp
                dendR[sec_type].append(this_dendR)
                this_neckR = (this_AR - 1) * this_dendR
                neckR[sec_type].append(this_neckR)
            for i, sec_type in enumerate(sec_types):
                axes[0][i].scatter(distances[sec_type], AR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')  # , fontsize=20)
                axes[0][i].set_title(sec_type)  # , fontsize=28)
                axes[1][i].scatter(distances[sec_type], dendR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')  # , fontsize=20)
                axes[1][i].set_title(sec_type)  # , fontsize=28)
                axes[2][i].scatter(distances[sec_type], neckR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')  # , fontsize=20)
                axes[2][i].set_title(sec_type)  # , fontsize=28)
    axes[0][0].set_ylabel('Amplitude Ratio')  # , fontsize=20)
    axes[1][0].set_ylabel('R_Dend (MOhm)')  # , fontsize=20)
    axes[2][0].set_ylabel('R_Neck (MOhm)')  # , fontsize=20)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig.subplots_adjust(hspace=0.45, wspace=0.3, left=0.06, right=0.94, top=0.94, bottom=0.06)
    if not title is None:
        fig.set_size_inches(20.8, 13)
        fig.savefig(data_dir+title+' - spine AR.svg', format='svg')
    plt.show()
    plt.close()


def plot_AR_EPSP_amp(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_spine_attenuation.
    Files contain voltage recordings from spine and branch while injecting EPSC-shaped currents into either spine or
    branch to measure the amplitude attenuation ratio.
    Creates a grid of 16 plots of EPSP amp vs. time, with one row per dendritic sec_type and four columns containing all
    stimulation and recording conditions.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in [sim for sim in f.itervalues() if sim.attrs['stim_loc'] == 'spine']:
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    spine_amp = {'spine': {}, 'branch': {}}
    branch_amp = {'spine': {}, 'branch': {}}
    fig, axes = plt.subplots(max(2, len(sec_types)), 4)
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        for sec_type in sec_types:
            distances[sec_type] = []
            for stim_loc in ['spine', 'branch']:
                spine_amp[stim_loc][sec_type] = []
                branch_amp[stim_loc][sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0'].attrs['amp']
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        branch_rec = rec
                        sec_type = rec.attrs['type']
                distances[sec_type].append(branch_rec.attrs['branch_distance'])
                for stim_loc, stim, tvec in [(stim_loc, f[indices[stim_loc]]['rec'], f[indices[stim_loc]]['time'])
                                             for stim_loc in ['spine', 'branch']]:
                    for rec in stim.itervalues():
                        if rec.attrs['description'] == 'branch':
                            branch_rec = rec
                        else:
                            spine_rec = rec
                    interp_t = np.arange(0, duration, 0.001)
                    interp_branch_vm = np.interp(interp_t, tvec[:], branch_rec[:])
                    interp_spine_vm = np.interp(interp_t, tvec[:], spine_rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline_branch = np.average(interp_branch_vm[left:right])
                    baseline_spine = np.average(interp_spine_vm[left:right])
                    left, right = time2index(interp_t, equilibrate, duration)
                    peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                    peak_spine = np.max(interp_spine_vm[left:right]) - baseline_spine
                    spine_amp[stim_loc][sec_type].append(peak_spine)
                    branch_amp[stim_loc][sec_type].append(peak_branch)
            for i, sec_type in enumerate(sec_types):
                axes[i][0].scatter(distances[sec_type], branch_amp['branch'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][1].scatter(distances[sec_type], spine_amp['branch'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][2].scatter(distances[sec_type], branch_amp['spine'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][3].scatter(distances[sec_type], spine_amp['spine'][sec_type], label=description_list[index],
                                   color=colors[index])
    for i, sec_type in enumerate(sec_types):
        for j, label in enumerate(['Stim Branch - Record Branch', 'Stim Branch - Record Spine',
                                   'Stim Spine - Record Branch', 'Stim Spine - Record Spine']):
            axes[i][j].set_xlabel('Distance from Dendrite Origin (um)')
            axes[i][j].set_ylabel('Input Loc: '+sec_type+'\nEPSP Amplitude (mV)')
            axes[i][j].set_title(label)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(19.2, 12)
        fig.savefig(data_dir+title+' - spine AR - EPSP amp.svg', format='svg')
    plt.show()
    plt.close()


def plot_AR_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_spine_attenuation.
    Files contain voltage recordings from spine and branch while injecting EPSC-shaped currents into either spine or
    branch to measure the amplitude attenuation ratio.
    Creates a grid of 16 plots of vm vs. time, with one row per dendritic sec_type and four columns containing all
    stimulation and recording conditions.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    fig, axes = plt.subplots(max(2, len(sec_types)), 4)
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        sec_type = rec.attrs['type']
                for stim_loc, stim, tvec in [(stim_loc, f[indices[stim_loc]]['rec'], f[indices[stim_loc]]['time'])
                                             for stim_loc in ['spine', 'branch']]:
                    for rec in stim.itervalues():
                        if rec.attrs['description'] == 'branch':
                            branch_rec = rec
                        else:
                            spine_rec = rec
                    j = 0 if stim_loc == 'branch' else 2
                    i = sec_types.index(sec_type)
                    interp_t = np.arange(0, duration, 0.01)
                    interp_branch_vm = np.interp(interp_t, tvec[:], branch_rec[:])
                    interp_spine_vm = np.interp(interp_t, tvec[:], spine_rec[:])
                    left, right = time2index(interp_t, equilibrate-5.0, duration)
                    interp_t -= interp_t[left] + 5.
                    axes[i][j].plot(interp_t[left:right], interp_branch_vm[left:right], color=colors[index])
                    axes[i][j+1].plot(interp_t[left:right], interp_spine_vm[left:right], color=colors[index])
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    for i, sec_type in enumerate(sec_types):
        for j, label in enumerate(['Stim Branch - Record Branch', 'Stim Branch - Record Spine',
                                   'Stim Spine - Record Branch', 'Stim Spine - Record Spine']):
            axes[i][j].set_xlabel('Time (ms)')
            axes[i][j].set_ylabel('Input Loc: '+sec_type+'\nVm (mV)')
            axes[i][j].set_title(label)
    if not description_list == [""]:
        axes[0][0].legend(handles=label_handles, framealpha=0.5, frameon=False)
    fig.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(19.2, 12)
        fig.savefig(data_dir+title+' - spine AR - traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_Rinp(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections to
    measure 1) peak r_inp, 2) steady-state r_inp, 3) their ratio, and 4) v_rest. Plots these parameters vs distance from
    dendrite origin, with one column per sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    peak = {}
    steady = {}
    sag = {}
    v_rest = {}
    fig, axes = plt.subplots(4, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for sec_type in sec_types:
            distances[sec_type] = []
            peak[sec_type] = []
            steady[sec_type] = []
            sag[sec_type] = []
            v_rest[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0']['stim']['0'].attrs['amp']
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + f['0']['stim']['0'].attrs['dur']
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                distances[sec_type].append(rec.attrs['branch_distance'])
                tvec = sim['time']
                this_rest, this_peak, this_steady = get_Rinp(tvec[:], rec[:], start, stop, amp)
                peak[sec_type].append(this_peak)
                steady[sec_type].append(this_steady)
                sag[sec_type].append(100*(1-this_steady/this_peak))
                v_rest[sec_type].append(this_rest)
            for i, sec_type in enumerate(sec_types):
                axes[0][i].scatter(distances[sec_type], peak[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[1][i].set_title(sec_type)
                axes[1][i].scatter(distances[sec_type], steady[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[2][i].scatter(distances[sec_type], sag[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[3][i].scatter(distances[sec_type], v_rest[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[3][i].set_xlabel('Distance from Dendrite Origin (um)')
    axes[0][1].set_ylabel('Input Resistance\nPeak (MOhm)')
    axes[1][1].set_ylabel('Input Resistance\nSteady-state (MOhm)')
    axes[2][1].set_ylabel('% Sag')
    axes[3][1].set_ylabel('Resting Vm (mV)')
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig.subplots_adjust(hspace=0.45, wspace=0.45, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 13)  # 19.2, 12)
        fig.savefig(data_dir+title+' - Rinp.svg', format='svg')
    plt.show()
    plt.close()


def plot_Rinp_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections.
    Plots vm vs. time,with one row per sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    fig, axes = plt.subplots(1, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + f['0']['stim']['0'].attrs['dur']
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                i = sec_types.index(sec_type)
                tvec = sim['time']
                interp_t = np.arange(0, stop, 0.01)
                interp_vm = np.interp(interp_t, tvec[:], rec[:])
                left, right = time2index(interp_t, start-5.0, stop)
                interp_t -= interp_t[left] + 5.
                axes[i].plot(interp_t[left:right], interp_vm[left:right], color=colors[index])
            for i, sec_type in enumerate(sec_types):
                axes[i].set_xlabel('Time (ms)')
                axes[i].set_ylabel('Vm (mV)')
                axes[i].set_title(sec_type)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0].legend(handles=label_handles, framealpha=0.5, frameon=False)
    fig.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(19.2, 12)
        fig.savefig(data_dir+title+' - Rinp - traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_Rinp_av_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections.
    Plots vm vs. time, with one row per sec_type, averaging all responses with the same input and recording location.
    This method subgroups trunk and apical sections as proximal or distal.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['soma', 'basal', 'trunk_prox', 'trunk_dist', 'apical_prox', 'apical_dist', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                if sec_type in ['trunk', 'apical']:
                    temp_sec_types.append(sec_type+'_prox')
                    temp_sec_types.append(sec_type+'_dist')
                else:
                    temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    rows = max(3, len(sec_types)/4)
    fig, axes = plt.subplots(rows, min(4, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + 200. # f['0']['stim']['0'].attrs['dur']
            average_vm = {}
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                if sec_type in ['trunk', 'apical']:
                    distance = rec.attrs['soma_distance'] if sec_type == 'trunk' else rec.attrs['soma_distance'] - \
                                                                                      rec.attrs['branch_distance']
                    if distance <= 150.:
                        sec_type += '_prox'
                    else:
                        sec_type += '_dist'
                i = sec_types.index(sec_type)
                tvec = sim['time']
                interp_t = np.arange(0, stop, 0.01)
                interp_vm = np.interp(interp_t, tvec[:], rec[:])
                left, right = time2index(interp_t, start-3.0, start-1.0)
                baseline = np.average(interp_vm[left:right])
                left, right = time2index(interp_t, start-5.0, stop)
                interp_vm = interp_vm[left:right] - baseline
                interp_t -= interp_t[left] + 5.
                interp_t = interp_t[left:right]
                if sec_type in average_vm:
                    average_vm[sec_type]['count'] += 1
                    average_vm[sec_type]['trace'] += interp_vm[:]
                else:
                    average_vm[sec_type] = {'count': 1, 'trace': interp_vm[:]}
            for i, sec_type in enumerate(sec_types):

                axes[i/4][i%4].plot(interp_t[:], average_vm[sec_type]['trace']/average_vm[sec_type]['count'],
                             color=colors[index])
                axes[i/4][i%4].set_xlabel('Time (ms)')  #, fontsize=20)
                axes[i/4][0].set_ylabel('Voltage (mV)')  #, fontsize=20)
                axes[i/4][i%4].set_title(sec_type)  #, fontsize=28)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0][0].legend(handles=label_handles, framealpha=0.5, frameon=False, fontsize=20)
    fig.subplots_adjust(hspace=0.5, wspace=0.4, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 13)
        fig.savefig(data_dir+title+' - Rinp - average traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_superimpose_conditions(rec_filename, legend=False):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    :param legend: bool
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if 'description' in sim.attrs and not sim.attrs['description'] in sim_ids:
            sim_ids.append(sim.attrs['description'])
        for rec in sim['rec'].itervalues():
            if 'description' in rec.attrs:
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            if not rec_id in (id['id'] for id in rec_ids):
                rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    fig, axes = plt.subplots(1, max(2, len(rec_ids)))
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for sim in f.itervalues():
        if 'description' in sim.attrs:
            sim_id = sim.attrs['description']
        else:
            sim_id = ''
        tvec = sim['time']
        for rec in sim['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    if legend:
        for i in range(len(rec_ids)):
            axes[i].legend(loc='best', framealpha=0.5, frameon=False)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.1)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_attenuation(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of 16 plots of EPSP amplitude vs. distance from dendrite origin.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    amps = {}
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            amps[input_loc] = {}
            for rec_loc in rec_locs:
                amps[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    start, end = time2index(interp_t, equilibrate, duration)
                    amps[input_loc][rec_loc].append(np.max(interp_vm[start:end]) - baseline)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].scatter(distances[input_loc], amps[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes[i][j].set_xlabel('Distance from Dendrite Origin (um)', fontsize='x-large')
                axes[i][0].set_ylabel('Spine Location: '+input_loc+'\nEPSP Amp (mV)', fontsize='xx-large')
            for j, rec_loc in enumerate(rec_locs):
                axes[0][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - EPSP attenuation.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_kinetics(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces a grid of 16 plots of EPSP kinetics vs. distance from dendrite origin.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    rise_taus = {}
    decay_taus = {}
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
            for rec_loc in rec_locs:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
                    interp_t = np.arange(0, duration, 0.001)
                    baseline = np.average(rec[left:right])
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    start, end = time2index(interp_t, equilibrate, duration)
                    interp_t = interp_t[start:end]
                    interp_vm = interp_vm[start:end] - baseline
                    amp = np.max(interp_vm)
                    t_peak = np.where(interp_vm == amp)[0][0]
                    interp_vm /= amp
                    interp_t -= interp_t[0]
                    rise_tau = optimize.curve_fit(model_exp_rise, interp_t[1:t_peak], interp_vm[1:t_peak], p0=0.3)[0]
                    decay_tau = optimize.curve_fit(model_exp_decay, interp_t[t_peak+1:]-interp_t[t_peak],
                                                   interp_vm[t_peak+1:], p0=5.)[0]
                    rise_taus[input_loc][rec_loc].append(rise_tau)
                    decay_taus[input_loc][rec_loc].append(decay_tau)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes1[i][j].scatter(distances[input_loc], rise_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes1[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes1[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Rise Tau (ms)')
                    axes1[i][j].set_title('Recording Loc: '+rec_loc)
                    axes2[i][j].scatter(distances[input_loc], decay_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes2[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes2[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Decay Tau (ms)')
                    axes2[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes1[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
        axes2[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig1.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig1.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig1.savefig(data_dir+title+' - EPSP attenuation - rise.svg', format='svg')
        fig2.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig2.savefig(data_dir+title+' - EPSP attenuation - decay.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_av_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft). This method subgroups
    trunk and apical sections as proximal or distal.
    Produces one figure containing a grid of 24 plots of EPSP vs. time, averaging all responses with the same input and
    recording location.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk_prox', 'trunk_dist', 'apical_prox', 'apical_dist', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                if input_loc in ['trunk', 'apical']:
                    temp_input_locs.append(input_loc+'_prox')
                    temp_input_locs.append(input_loc+'_dist')
                else:
                    temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        average_vm = {}
        for input_loc in input_locs:
            average_vm[input_loc] = {}
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                if input_loc in ['trunk', 'apical']:
                    spine_rec = sim['rec']['3'].attrs
                    distance = spine_rec['soma_distance'] if input_loc == 'trunk' else spine_rec['soma_distance'] - \
                                                                                       spine_rec['branch_distance']
                    if distance <= 150.:
                        input_loc += '_prox'
                    else:
                        input_loc += '_dist'
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    left, right = time2index(interp_t, equilibrate-5.0, duration)
                    interp_vm = interp_vm[left:right] - baseline
                    interp_t -= interp_t[left] + 5.
                    interp_t = interp_t[left:right]
                    if rec_loc in average_vm[input_loc]:
                        average_vm[input_loc][rec_loc]['count'] += 1
                        average_vm[input_loc][rec_loc]['trace'] += interp_vm[:]
                    else:
                        average_vm[input_loc][rec_loc] = {'count': 1, 'trace': interp_vm[:]}
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].plot(interp_t[:], average_vm[input_loc][rec_loc]['trace'] /
                            average_vm[input_loc][rec_loc]['count'], color=colors[index], label=description_list[index])
                    axes[i][j].set_xlabel('Time (ms)', fontsize='x-large')
                axes[i][0].set_ylabel('Spine Location:\n'+input_loc+'\nEPSP (mV)', fontsize='xx-large')
            for j, rec_loc in enumerate(rec_locs):
                axes[0][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - EPSP average traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_i_attenuation(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces one figure containing a grid of 15 plots of EPSP amplitude vs. distance from soma.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    amps = {}
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            amps[input_loc] = {}
            for rec_loc in rec_locs:
                amps[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    if rec_loc == 'branch':
                        distances[input_loc].append(rec.attrs['soma_distance'])
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    start, end = time2index(interp_t, equilibrate, duration)
                    amps[input_loc][rec_loc].append(np.max(interp_vm[start:end]) - baseline)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].scatter(distances[input_loc], amps[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes[i][j].set_xlabel('Distance from Soma (um)', fontsize='xx-large')
                axes[i][0].set_ylabel('Input Loc: '+input_loc+'\nEPSP Amp (mV)', fontsize='xx-large')
            for j, rec_loc in enumerate(rec_locs):
                axes[0][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig.subplots_adjust(hspace=0.45, wspace=0.25, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)
        fig.savefig(data_dir+title+' - EPSP_i attenuation.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_i_kinetics(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces a grid of 15 plots of EPSP kinetics vs. distance from soma.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    rise_taus = {}
    decay_taus = {}
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
            for rec_loc in rec_locs:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    if rec_loc == 'branch':
                        distances[input_loc].append(rec.attrs['soma_distance'])
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    start, end = time2index(interp_t, equilibrate, duration)
                    interp_t = interp_t[start:end]
                    interp_vm = interp_vm[start:end] - baseline
                    amp = np.max(interp_vm)
                    t_peak = np.where(interp_vm == amp)[0][0]
                    interp_vm /= amp
                    interp_t -= interp_t[0]
                    rise_tau = optimize.curve_fit(model_exp_rise, interp_t[1:t_peak], interp_vm[1:t_peak], p0=0.3)[0]
                    decay_tau = optimize.curve_fit(model_exp_decay, interp_t[t_peak+1:]-interp_t[t_peak],
                                                   interp_vm[t_peak+1:], p0=5.)[0]
                    rise_taus[input_loc][rec_loc].append(rise_tau)
                    decay_taus[input_loc][rec_loc].append(decay_tau)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes1[i][j].scatter(distances[input_loc], rise_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes1[i][j].set_xlabel('Distance from Soma (um)', fontsize='xx-large')
                    axes2[i][j].scatter(distances[input_loc], decay_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes2[i][j].set_xlabel('Distance from Soma (um)', fontsize='xx-large')
                axes1[i][0].set_ylabel('Input Loc: '+input_loc+'\nEPSP Rise (ms)', fontsize='xx-large')
                axes2[i][0].set_ylabel('Input Loc: '+input_loc+'\nEPSP Decay (ms)', fontsize='xx-large')
            for j, rec_loc in enumerate(rec_locs):
                axes1[0][j].set_title('Recording Loc: '+rec_loc)
                axes2[0][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes1[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
        axes2[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig1.subplots_adjust(hspace=0.45, wspace=0.25, left=0.05, right=0.95, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.45, wspace=0.25, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig1.set_size_inches(20.8, 15.6)  # 19.2, 12)
        fig1.savefig(data_dir+title+' - EPSP_i attenuation - rise.svg', format='svg')
        fig2.set_size_inches(20.8, 15.6)  # 19.2, 12)
        fig2.savefig(data_dir+title+' - EPSP_i attenuation - decay.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_i_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces a grid of 15 plots of vm vs time, superimposing all responses with the same input and recording location.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                i = input_locs.index(input_loc)
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    j = rec_locs.index(rec_loc)
                    interp_t = np.arange(0, duration, 0.01)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-5., equilibrate+50.)
                    interp_t -= interp_t[left] + 5.
                    axes[i][j].plot(interp_t[left:right], interp_vm[left:right], color=colors[index])
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].set_xlabel('Time (ms)')
                    axes[i][j].set_ylabel('Input Loc: '+input_loc+'\nVm (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0][0].legend(handles=label_handles, framealpha=0.5, frameon=False)
    fig.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(19.2, 12)
        fig.savefig(data_dir+title+' - EPSP_i attenuation - traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_EPSP_i_av_vm(rec_file_list, description_list="", title=None):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (basal, trunk, apical, tuft). This method
    subgroups trunk and apical sections as proximal or distal.
    Produces a grid of 18 plots of EPSP_i vs time, averaging all responses with the same input and recording location.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    :param title: str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk_prox', 'trunk_dist', 'apical_prox', 'apical_dist', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                if input_loc in ['trunk', 'apical']:
                    temp_input_locs.append(input_loc+'_prox')
                    temp_input_locs.append(input_loc+'_dist')
                else:
                    temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                i = input_locs.index(input_loc)
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    j = rec_locs.index(rec_loc)
                    interp_t = np.arange(0, duration, 0.01)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-5., equilibrate+50.)
                    interp_t -= interp_t[left] + 5.
                    axes[i][j].plot(interp_t[left:right], interp_vm[left:right], color=colors[index])
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].set_xlabel('Time (ms)')
                    axes[i][j].set_ylabel('Input Loc:\n'+input_loc+'\nVm (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0][0].legend(loc='best', handles=label_handles, framealpha=0.5, frameon=False)
    fig.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(19.2, 12)
        fig.savefig(data_dir+title+' - EPSP_i average traces.svg', format='svg')
    plt.show()
    plt.close()


def plot_synaptic_parameter(rec_file_list, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if description_list is None:
        description_list = ["" for rec in rec_file_list]
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        param_list = [dataset for dataset in f.values()[0] if not dataset == 'distances']
        fig, axes = plt.subplots(max(2,len(param_list)), max(2, len(f)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for i, sec_type in enumerate(f):
                for j, dataset in enumerate(param_list):
                    axes[j][i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:],
                                       label=description_list[index], color=colors[index])
                    axes[j][i].set_title(sec_type+' spines')
                    axes[j][i].set_xlabel('Distance from Soma (um)')
                    axes[j][i].set_ylabel(f.attrs['syn_type']+': '+dataset+'\n'+f.attrs[dataset])
                    axes[j][i].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_param_distribution(cell, syn_type, param_name, title=None):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified synaptic parameter for all spines. Used while
    debugging specification of synaptic parameters.
    :param cell: :class:'HocCell'
    :param syn_type: str
    :param param_name: str
    :param title: str
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        syn_list = []
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for spine in branch.spines:
                syn_list.extend(spine.synapses)
        for syn in [syn for syn in syn_list if syn_type in syn._syn]:
            distances.append(cell.get_distance_to_node(cell.tree.root, syn.node.parent.parent, syn.loc))
            if sec_type == 'basal':
                    distances[-1] *= -1
            param_vals.append(getattr(syn.target(syn_type), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    if not title is None:
        plt.set_size_inches(19.2, 12)
        plt.savefig(data_dir+title+' - '+syn_type+'_'+param_name+' distribution.svg', format='svg')
    plt.show()
    plt.close()
    print '# spines: ', len(cell.get_nodes_of_subtype('spine_head'))


def plot_mech_param_distribution(cell, mech_name, param_name, title=None):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_name: str
    :param param_name: str
    :param title: str
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                distances.append(cell.get_distance_to_node(cell.tree.root, branch, seg.x))
                if sec_type == 'basal':
                    distances[-1] *= -1
                param_vals.append(getattr(getattr(seg, mech_name), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    if not title is None:
        plt.set_size_inches(19.2, 12)
        plt.savefig(data_dir+title+' - '+mech_name+'_'+param_name+' distribution.svg', format='svg')
    plt.show()
    plt.close()


def plot_expected_vs_actual_from_raw(expected_filename, actual_file_list, description_list="", location_list=None,
                                     title=None):
    """
    Expects each file in actual_file_list to be generated by parallel_clustered_ or
    parallel_distributed_branch_cooperativity. Files contain simultaneous voltage recordings from 3 locations (soma,
    trunk, dendrite origin) during synchronous stimulation of branches. Spines are distributed across 4 dendritic
    sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of expected EPSP amplitude
    vs. actual EPSP amplitude.
    Superimposes results from multiple branches in one color.
    Superimposes results from multiple files in list using different colors.
    :param expected_filename: str
    :param actual_file_list: list of str
    :param description_list: list of str
    :param location_list: list of str
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = []
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    with h5py.File(data_dir+expected_filename+'.hdf5', 'r') as expected_file:
        expected_index_map = get_expected_spine_index_map(expected_file)
        for index, rec_filename in enumerate(actual_file_list):
            with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
                path_indexes = {input_loc: [] for input_loc in input_locs}
                for sim in actual_file.itervalues():
                    path_index = sim.attrs['path_index']
                    path_type = sim.attrs['path_type']
                    if not path_index in path_indexes[path_type] and path_type in input_locs:
                        path_indexes[path_type].append(path_index)
                for i, input_loc in enumerate(input_locs):
                    for path_index in path_indexes[input_loc]:
                        sorted_sim_keys = [key for key in actual_file if actual_file[key].attrs['path_index'] ==
                                                                                                        path_index]
                        sorted_sim_keys.sort(key=lambda x: len(actual_file[x].attrs['syn_indexes']))
                        expected_dict, actual_dict = get_expected_vs_actual(expected_file, actual_file,
                                                                            expected_index_map, sorted_sim_keys)
                        for j, location in enumerate(rec_locs):
                            axes[i][j].plot(expected_dict[location], actual_dict[location], color=colors[index])
            label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel('Expected EPSP Amp (mV)')  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\nActual EPSP Amp (mV)')  # , fontsize='xx-large')
    if not description_list == [""]:
        axes[0][0].legend(loc='best', handles=label_handles, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - branch cooperativity.svg', format='svg')
    plt.show()
    plt.close()


def plot_expected_vs_actual_from_processed(actual_file_list, description_list=None, location_list=None, title=None):
    """
    Expects each file in actual_file_list to be generated by passing the output of parallel_clustered_ or
    parallel_distributed_branch_cooperativity through export_nmdar_cooperativity. Files contain expected vs. actual
    measurements from simultaneous voltage recordings from 3 locations (soma, trunk, dendrite origin) during synchronous
    stimulation of branches. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of expected EPSP amplitude
    vs. actual EPSP amplitude.
    Superimposes results from multiple branches in two colors, separating by the path_category (e.g. proximal, distal,
    or terminal).
    Superimposes results from multiple files in list using different colors.
    :param actual_file_list: list of str
    :param description_list: list of str
    :param location_list: list of str
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec_loc in sim:
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = [{input_loc: {} for input_loc in input_locs} for i in range(len(actual_file_list))]
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(actual_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
            if description_list is None:
                if 'description' in actual_file.attrs:
                    description_list = [actual_file.attrs['description']]
                else:
                    description_list = [""]
            elif 'description' in actual_file.attrs:
                description_list.append(actual_file.attrs['description'])
            else:
                description_list.append("")
            for sim in actual_file.itervalues():
                input_loc = sim.attrs['path_type']
                path_category = sim.attrs['path_category']
                if path_category == 'proximal':
                    color = colors[index*2]
                else:
                    color = colors[index*2+1]
                if path_category not in label_handles[index][input_loc]:
                    label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color=color,
                                                        label=description_list[index]+': '+path_category)
                i = input_locs.index(input_loc)
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].plot(sim[rec_loc]['expected'][:], sim[rec_loc]['actual'][:], color=color)
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel('Expected EPSP Amp (mV)')  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\nActual EPSP Amp (mV)')  # , fontsize='xx-large')
        label_handle = []
        for index in range(len(label_handles)):
            label_handle.extend(label_handles[index][input_loc].values())
        axes[i][0].legend(loc='best', handles=label_handle, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - branch cooperativity.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_contribution_from_raw(expected_filename, actual_file_list, description_list="", location_list=None,
                                     title=None):
    """
    Expects each item in actual_file_list to be a tuple containing the names of files generated by parallel_clustered_
    or parallel_distributed_branch_cooperativity with and without NMDARs. Files contain simultaneous voltage recordings
    from 3 locations (soma, trunk, dendrite origin) during synchronous stimulation of branches. Spines are distributed
    across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of expected EPSP amplitude
    vs. actual EPSP amplitude.
    Superimposes results from multiple branches in one color.
    Superimposes results from multiple files in list using different colors.
    :param expected_filename: str
    :param actual_file_list: list of tuples of str
    :param description_list: list of str
    :param location_list: list of str
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0][0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = []
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    with h5py.File(data_dir+expected_filename+'.hdf5', 'r') as expected_file:
        expected_index_map = get_expected_spine_index_map(expected_file)
        for index, (with_nmda_filename, without_nmda_filename) in enumerate(actual_file_list):
            with h5py.File(data_dir+with_nmda_filename+'.hdf5', 'r') as with_nmda_file:
                path_indexes = {input_loc: [] for input_loc in input_locs}
                for sim in with_nmda_file.itervalues():
                    path_index = sim.attrs['path_index']
                    path_type = sim.attrs['path_type']
                    if not path_index in path_indexes[path_type] and path_type in input_locs:
                        path_indexes[path_type].append(path_index)
                for i, input_loc in enumerate(input_locs):
                    for path_index in path_indexes[input_loc]:
                        sorted_sim_keys = [key for key in with_nmda_file if with_nmda_file[key].attrs['path_index'] ==
                                                                                                        path_index]
                        sorted_sim_keys.sort(key=lambda x: len(with_nmda_file[x].attrs['syn_indexes']))
                        expected_dict, with_nmda_dict = get_expected_vs_actual(expected_file, with_nmda_file,
                                                                               expected_index_map, sorted_sim_keys)
            with h5py.File(data_dir+without_nmda_filename+'.hdf5', 'r') as without_nmda_file:
                path_indexes = {input_loc: [] for input_loc in input_locs}
                for sim in without_nmda_file.itervalues():
                    path_index = sim.attrs['path_index']
                    path_type = sim.attrs['path_type']
                    if not path_index in path_indexes[path_type] and path_type in input_locs:
                        path_indexes[path_type].append(path_index)
                for i, input_loc in enumerate(input_locs):
                    for path_index in path_indexes[input_loc]:
                        sorted_sim_keys = [key for key in without_nmda_file if
                                           without_nmda_file[key].attrs['path_index'] == path_index]
                        sorted_sim_keys.sort(key=lambda x: len(without_nmda_file[x].attrs['syn_indexes']))
                        expected_dict, without_nmda_dict = get_expected_vs_actual(expected_file, without_nmda_file,
                                                                                  expected_index_map, sorted_sim_keys)
                        for j, location in enumerate(rec_locs):
                            nmda_contribution = (np.array(with_nmda_dict[location]) -
                                np.array(without_nmda_dict[location])) / np.array(without_nmda_dict[location]) * 100.
                            axes[i][j].plot(expected_dict[location], nmda_contribution, color=colors[index])
                            print np.max(nmda_contribution)
            label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel('Expected EPSP Amp (mV)')  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\nNMDAR Contribution (%)')  # , fontsize='xx-large')
    if not description_list == [""]:
        axes[0][0].legend(loc='best', handles=label_handles, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - NMDAR contribution.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_contribution_from_processed(actual_file_list, description_list=None, location_list=None, x='expected',
                                             title=None):
    """
    Expects each tuple in actual_file_list to be generated by passing the output of parallel_clustered_ or
    parallel_distributed_branch_cooperativity, with and without nmdars, through export_nmdar_cooperativity. Files
    contain expected vs. actual measurements from simultaneous voltage recordings from 3 locations (soma, trunk,
    dendrite origin) during synchronous stimulation of branches. Spines are distributed across 4 dendritic sec_types
    (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of % contribution of
    NMDARs to EPSP amplitude. The parameter 'x' determines whether to plot versus expected EPSP amplitude or distance
    from soma. For apical dendrites, this distance is from point of origin along the trunk to soma.
    Superimposes results from multiple branches in two colors, separating by the path_category (e.g. proximal, distal,
    or terminal).
    Superimposes results from multiple files in list using different colors.
    :param actual_file_list: list of tuple of str
    :param description_list: list of str
    :param location_list: list of str
    :param x: str in ['expected', 'distance']
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0][0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec_loc in sim:
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = [{input_loc: {} for input_loc in input_locs} for i in range(len(actual_file_list))]
    distances = {input_loc: {} for input_loc in input_locs}
    peaks = {input_loc: {rec_loc: {} for rec_loc in rec_locs} for input_loc in input_locs}
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, (with_nmda_filename, without_nmda_filename) in enumerate(actual_file_list):
        with h5py.File(data_dir+with_nmda_filename+'.hdf5', 'r') as with_nmda_file:
            with h5py.File(data_dir+without_nmda_filename+'.hdf5', 'r') as without_nmda_file:
                if description_list is None:
                    if 'description' in with_nmda_file.attrs:
                        description_list = [with_nmda_file.attrs['description']]
                    else:
                        description_list = [""]
                elif len(description_list) < len(actual_file_list):
                    if 'description' in with_nmda_file.attrs:
                        description_list.append(with_nmda_file.attrs['description'])
                    else:
                        description_list.append("")
                for path_index, sim in with_nmda_file.iteritems():
                    input_loc = sim.attrs['path_type']
                    if input_loc == 'apical':
                        distance = sim.attrs['origin_distance']
                    else:
                        distance = sim.attrs['soma_distance']
                    path_category = sim.attrs['path_category']
                    if path_category == 'proximal':
                        color = colors[index*2]
                    else:
                        color = colors[index*2+1]
                    if path_category not in distances[input_loc]:
                        distances[input_loc][path_category] = []
                        for rec_loc in rec_locs:
                            peaks[input_loc][rec_loc][path_category] = []
                        if x == 'expected':
                            label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color=color,
                                                            label=description_list[index]+': '+path_category)
                        else:
                            label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color='none',
                                                            marker='o', markeredgecolor=color, markerfacecolor=color,
                                                            label=description_list[index]+': '+path_category)
                    distances[input_loc][path_category].append(distance)
                    i = input_locs.index(input_loc)
                    for j, rec_loc in enumerate(rec_locs):
                        expected = sim[rec_loc]['expected'][:]
                        with_nmda = sim[rec_loc]['actual'][:]
                        without_nmda = without_nmda_file[path_index][rec_loc]['actual'][:]
                        nmda_contribution = (with_nmda - without_nmda) / without_nmda * 100.
                        peak = np.max(nmda_contribution)
                        peaks[input_loc][rec_loc][path_category].append(peak)
                        if x == 'expected':
                            axes[i][j].plot(expected, nmda_contribution, color=color)
        if x == 'distance':
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    for k, path_category in enumerate(distances[input_loc]):
                        color = colors[index*2+k]
                        axes[i][j].scatter(distances[input_loc][path_category],
                                           peaks[input_loc][rec_loc][path_category], color=color)
            xlabel = 'Distance to Soma (um)'
            ylabel = 'Peak NMDAR Contribution (%)'
        else:
            xlabel = 'Expected EPSP Amp (mV)'
            ylabel = 'NMDAR Contribution (%)'
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel(xlabel)  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\n'+ylabel)  # , fontsize='xx-large')
        label_handle = []
        for index in range(len(label_handles)):
            label_handle.extend(label_handles[index][input_loc].values())
        axes[i][0].legend(loc='best', handles=label_handle, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - NMDAR contribution.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_supralinearity_from_raw(expected_filename, actual_file_list, description_list="", location_list=None,
                                       title=None):
    """
    Expects each file in actual_file_list to be generated by parallel_clustered_ or
    parallel_distributed_branch_cooperativity. Files contain simultaneous voltage recordings from 3 locations (soma,
    trunk, dendrite origin) during synchronous stimulation of branches. Spines are distributed across 4 dendritic
    sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of expected EPSP amplitude
    vs. percentage of actual EPSP amplitude greater than linear.
    Superimposes results from multiple branches in one color.
    Superimposes results from multiple files in list using different colors.
    :param expected_filename: str
    :param actual_file_list: list of str
    :param description_list: list of str
    :param location_list: list of str
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = []
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    with h5py.File(data_dir+expected_filename+'.hdf5', 'r') as expected_file:
        expected_index_map = get_expected_spine_index_map(expected_file)
        for index, rec_filename in enumerate(actual_file_list):
            with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
                path_indexes = {input_loc: [] for input_loc in input_locs}
                for sim in actual_file.itervalues():
                    path_index = sim.attrs['path_index']
                    path_type = sim.attrs['path_type']
                    if not path_index in path_indexes[path_type] and path_type in input_locs:
                        path_indexes[path_type].append(path_index)
                for i, input_loc in enumerate(input_locs):
                    for path_index in path_indexes[input_loc]:
                        sorted_sim_keys = [key for key in actual_file if actual_file[key].attrs['path_index'] ==
                                                                                                        path_index]
                        sorted_sim_keys.sort(key=lambda x: len(actual_file[x].attrs['syn_indexes']))
                        expected_dict, actual_dict = get_expected_vs_actual(expected_file, actual_file,
                                                                            expected_index_map, sorted_sim_keys)
                        for j, location in enumerate(rec_locs):
                            expected = np.array(expected_dict[location])
                            actual = np.array(actual_dict[location])
                            supralinearity = (actual - expected) / expected * 100.
                            axes[i][j].plot(expected_dict[location], supralinearity, color=colors[index])
                            print np.max(supralinearity)
            label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel('Expected EPSP Amp (mV)')  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\nNMDAR Nonlinearity (%)')  # , fontsize='xx-large')
    if not description_list == [""]:
        axes[0][0].legend(loc='best', handles=label_handles, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - branch supralinearity.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_supralinearity_from_processed(actual_file_list, description_list=None, location_list=None, x='expected',
                                             title=None):
    """
    Expects each file in actual_file_list to be generated by passing the output of parallel_clustered_ or
    parallel_distributed_branch_cooperativity through export_nmdar_cooperativity. Files contain expected vs. actual
    measurements from simultaneous voltage recordings from 3 locations (soma, trunk, dendrite origin) during synchronous
    stimulation of branches. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of percentage of actual
    EPSP amplitude greater than linear. The parameter 'x' determines whether to plot versus expected EPSP amplitude or
    distance from soma. For apical dendrites, this distance is from point of origin along the trunk to soma.
    Superimposes results from multiple branches in two colors, separating by the path_category (e.g. proximal, distal,
    or terminal).
    Superimposes results from multiple files in list using different colors.
    :param actual_file_list: list of str
    :param description_list: list of str
    :param location_list: list of str
    :param x: str in ['expected', 'distance']
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if location_list is None:
        location_list = ['soma', 'branch']
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec_loc in sim:
                if not rec_loc in temp_rec_locs and rec_loc in location_list:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    label_handles = [{input_loc: {} for input_loc in input_locs} for i in range(len(actual_file_list))]
    distances = {input_loc: {} for input_loc in input_locs}
    peaks = {input_loc: {rec_loc: {} for rec_loc in rec_locs} for input_loc in input_locs}
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(actual_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
            if description_list is None:
                if 'description' in actual_file.attrs:
                    description_list = [actual_file.attrs['description']]
                else:
                    description_list = [""]
            elif len(description_list) < len(actual_file_list):
                if 'description' in actual_file.attrs:
                    description_list.append(actual_file.attrs['description'])
                else:
                    description_list.append("")
            for sim in actual_file.itervalues():
                input_loc = sim.attrs['path_type']
                if input_loc == 'apical':
                    distance = sim.attrs['origin_distance']
                else:
                    distance = sim.attrs['soma_distance']
                path_category = sim.attrs['path_category']
                if path_category == 'proximal':
                    color = colors[index*2]
                else:
                    color = colors[index*2+1]
                if path_category not in distances[input_loc]:
                    distances[input_loc][path_category] = []
                    for rec_loc in rec_locs:
                        peaks[input_loc][rec_loc][path_category] = []
                    if x == 'expected':
                        label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color=color,
                                                        label=description_list[index]+': '+path_category)
                    else:
                        label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color='none', marker='o',
                         markeredgecolor=color, markerfacecolor=color, label=description_list[index]+': '+path_category)
                distances[input_loc][path_category].append(distance)
                i = input_locs.index(input_loc)
                for j, rec_loc in enumerate(rec_locs):
                    expected = sim[rec_loc]['expected'][:]
                    actual = sim[rec_loc]['actual'][:]
                    supralinearity = (actual - expected) / expected * 100.
                    peak = np.max(supralinearity)
                    peaks[input_loc][rec_loc][path_category].append(peak)
                    if x == 'expected':
                        axes[i][j].plot(expected, supralinearity, color=color)
        if x == 'distance':
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    for k, path_category in enumerate(distances[input_loc]):
                        color = colors[index*2+k]
                        axes[i][j].scatter(distances[input_loc][path_category],
                                           peaks[input_loc][rec_loc][path_category], color=color)
            xlabel = 'Distance to Soma (um)'
            ylabel = 'Peak NMDAR Supralinearity (%)'
        else:
            xlabel = 'Expected EPSP Amp (mV)'
            ylabel = 'NMDAR Nonlinearity (%)'
    for j, location in enumerate(rec_locs):
        axes[0][j].set_title('Recording loc: '+location)
        axes[-1][j].set_xlabel(xlabel)  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i][0].set_ylabel('Spine Location: '+input_loc+'\n'+ylabel)  # , fontsize='xx-large')
        label_handle = []
        for index in range(len(label_handles)):
            label_handle.extend(label_handles[index][input_loc].values())
        axes[i][0].legend(loc='best', handles=label_handle, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - branch supralinearity.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_conductance_from_raw(actual_file_list, description_list="", object_description='NMDA_g', title=None):
    """
    Expects each file in actual_file_list to be generated by parallel_clustered_ or
    parallel_distributed_branch_cooperativity. Files should contain recordings of NMDA_KIN conductance in single spines
    that were activated first in a sequence of stimulated spines, and labeled with the description 'NMDA_g'. Spines are
    distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure for each sec_type containing a plot of number of activated spines vs. peak NMDA conductance.
    Superimposes results from multiple spines of the same sec_type using the same color.
    Superimposes results from multiple files in list using different colors.
    :param actual_file_list: list of str
    :param description_list: list of str
    :param object_description: str
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
    # enforce the default order of input locations for plotting, but allow for adding or subtracting sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    fig, axes = plt.subplots(2, 2)
    label_handles = []
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(actual_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
            path_indexes = {input_loc: [] for input_loc in input_locs}
            for sim in actual_file.itervalues():
                path_index = sim.attrs['path_index']
                path_type = sim.attrs['path_type']
                if not path_index in path_indexes[path_type] and path_type in input_locs:
                    path_indexes[path_type].append(path_index)
            for i, input_loc in enumerate(input_locs):
                for path_index in path_indexes[input_loc]:
                    sorted_sim_keys = [key for key in actual_file if actual_file[key].attrs['path_index'] ==
                                                                                                    path_index]
                    sorted_sim_keys.sort(key=lambda x: len(actual_file[x].attrs['syn_indexes']))
                    peak_conductance = []
                    for sim in [actual_file[key] for key in sorted_sim_keys]:
                        rec = (rec[:] for rec in sim['rec'].itervalues() if
                               rec.attrs['description'] == object_description).next()
                        peak_conductance.append(np.max(rec))
                    axes[i/2][i%2].plot(range(1, len(sorted_sim_keys)+1), peak_conductance, color=colors[index])
            axes[i/2][i%2].set_xlabel('Input Number')  # , fontsize='x-large')
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    for i, input_loc in enumerate(input_locs):
        axes[i/2][i%2].set_ylabel('Spine Location: '+input_loc+'\nNMDAR Conductance (uS)')  # , fontsize='xx-large')
    if not description_list == [""]:
        axes[0][0].legend(loc='best', handles=label_handles, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - nmdar conductance.svg', format='svg')
    plt.show()
    plt.close()


def plot_nmdar_conductance_from_processed(actual_file_list, description_list=None, object_description='NMDA_g',
                                          x='number', title=None):
    """
    Expects each file in actual_file_list to be generated by passing the output of parallel_clustered_ or
    parallel_distributed_branch_cooperativity through export_nmdar_cooperativity. Files should contain recordings of
    NMDA_KIN conductance in single spines that were activated first in a sequence of stimulated spines, and labeled with
    the description 'NMDA_g'. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of up to 12 plots (4 sec_types by 3 recording locs) of NMDAR conductance. The
    parameter 'x' determines whether to plot versus number of inputs or distance from soma. For apical dendrites, this
    distance is from point of origin along the trunk to soma.
    Superimposes results from multiple branches in two colors, separating by the path_category (e.g. proximal, distal,
    or terminal).
    Superimposes results from multiple files in list using different colors.
    :param actual_file_list: list of str
    :param description_list: list of str
    :param object_description: str
    :param x: str in ['number', 'distance']
    :param title: str
    """
    if not type(actual_file_list) == list:
        actual_file_list = [actual_file_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+actual_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['path_type']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
    # enforce the default order of input locations for plotting, but allow for adding or subtracting sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)))
    label_handles = [{input_loc: {} for input_loc in input_locs} for i in range(len(actual_file_list))]
    distances = {input_loc: {} for input_loc in input_locs}
    peaks = {input_loc: {} for input_loc in input_locs}
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(actual_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as actual_file:
            if description_list is None:
                if 'description' in actual_file.attrs:
                    description_list = [actual_file.attrs['description']]
                else:
                    description_list = [""]
            elif len(description_list) < len(actual_file_list):
                if 'description' in actual_file.attrs:
                    description_list.append(actual_file.attrs['description'])
                else:
                    description_list.append("")
            for sim in actual_file.itervalues():
                input_loc = sim.attrs['path_type']
                if input_loc == 'apical':
                    distance = sim.attrs['origin_distance']
                else:
                    distance = sim.attrs['soma_distance']
                path_category = sim.attrs['path_category']
                if path_category == 'proximal':
                    color = colors[index*2]
                else:
                    color = colors[index*2+1]
                if path_category not in distances[input_loc]:
                    distances[input_loc][path_category] = []
                    peaks[input_loc][path_category] = []
                    if x == 'number':
                        label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color=color,
                                                        label=description_list[index]+': '+path_category)
                    else:
                        label_handles[index][input_loc][path_category] = mlines.Line2D([], [], color='none', marker='o',
                         markeredgecolor=color, markerfacecolor=color, label=description_list[index]+': '+path_category)
                distances[input_loc][path_category].append(distance)
                i = input_locs.index(input_loc)
                actual = sim[object_description]['actual'][:]
                peak = np.max(actual)
                peaks[input_loc][path_category].append(peak)
                if x == 'number':
                    axes[i].plot(range(1, len(actual)+1), actual, color=color)
        if x == 'distance':
            for i, input_loc in enumerate(input_locs):
                for k, path_category in enumerate(distances[input_loc]):
                    color = colors[index*2+k]
                    axes[i].scatter(distances[input_loc][path_category], peaks[input_loc][path_category], color=color)
            xlabel = 'Distance to Soma (um)'
            ylabel = 'Peak NMDAR Conductance (uS)'
        else:
            xlabel = 'Input Number'
            ylabel = 'NMDAR Conductance (uS)'
    axes[0].set_title('Synaptic NMDAR Conductance')
    axes[-1].set_xlabel(xlabel)  # , fontsize='x-large')
    for i, input_loc in enumerate(input_locs):
        axes[i].set_ylabel('Spine Location: '+input_loc+'\n'+ylabel)  # , fontsize='xx-large')
        label_handle = []
        for index in range(len(label_handles)):
            label_handle.extend(label_handles[index][input_loc].values())
        axes[i].legend(loc='best', handles=label_handle, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.05)
    if not title is None:
        fig.set_size_inches(20.8, 15.6)  # 19.2, 12)19.2, 12)
        fig.savefig(data_dir+title+' - NMDAR conductance.svg', format='svg')
    plt.show()
    plt.close()


def process_patterned_input_simulation(rec_filename, title, dt=0.02):
    """

    :param rec_file_name: str
    :param title: str
    # remember .attrs['phase_offset'] could be inside ['train'] for old files
    """
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        sim = f.values()[0]
        equilibrate = sim.attrs['equilibrate']
        track_equilibrate = sim.attrs['track_equilibrate']
        track_length = sim.attrs['track_length']
        input_field_duration = sim.attrs['input_field_duration']
        duration = sim.attrs['duration']
        stim_dt = sim.attrs['stim_dt']
        bins = int((1.5 + track_length) * input_field_duration / 20.)
        track_duration = duration - equilibrate - track_equilibrate
        stim_t = np.arange(-track_equilibrate, track_duration, stim_dt)
        intervals = []
        for sim in f.values():
            for train in sim['train'].values():
                if len(train) > 0:
                    for i in range(len(train) - 1):
                        intervals.append(train[i+1] - train[i])
        pop_input = [get_binned_firing_rate(sim['train'].values(), stim_t) for sim in f.values()]
        pop_psd = []
        for this_pop_input in pop_input:
            pop_freq, this_pop_psd = signal.periodogram(this_pop_input, 1000./stim_dt)
            pop_psd.append(this_pop_psd)
        pop_psd = np.mean(pop_psd, axis=0)
        left = np.where(pop_freq >= 4.)[0][0]
        right = np.where(pop_freq >= 11.)[0][0]
        pop_psd /= np.max(pop_psd[left:right])
        mean_input = np.mean(pop_input, axis=0)
        if 'successes' in f.values()[0]:
            successes = [get_binned_firing_rate(sim['successes'].values(), stim_t) for sim in f.values()]
            mean_successes = np.mean(successes, axis=0)
        if 'inh_train' in f.values()[0]:
            inh_input = [get_binned_firing_rate(sim['inh_train'].values(), stim_t) for sim in f.values()]
            mean_inh_input = np.mean(inh_input, axis=0)
        output = [get_smoothed_firing_rate([sim['output']], stim_t) for sim in f.values()]
        mean_output = np.mean(output, axis=0)
        start = int(track_equilibrate/stim_dt)
        fig, axes = plt.subplots(3, 1)
        axes[0].plot(stim_t[start:], mean_input[start:], label='Total Excitatory Input Spike Rate', c='b')
        if 'successes' in f.values()[0]:
            axes[0].plot(stim_t[start:], mean_successes[start:], label='Total Excitatory Input Success Rate', c='g')
        if 'inh_train' in f.values()[0]:
            axes[1].plot(stim_t[start:], mean_inh_input[start:], label='Total Inhibitory Input Spike Rate', c='k')
        axes[2].plot(stim_t[start:], mean_output[start:], label='Single Cell Output Spike Rate', c='r')
        for ax in axes:
            ax.legend(loc='upper left', frameon=False, framealpha=0.5)
        axes[2].set_xlabel('Time (ms)')
        axes[1].set_ylabel('Event Rate (Hz)')
        axes[0].set_title(title)
        plt.show()
        plt.close()
        plt.hist(intervals, bins=int(max(intervals)/3.), normed=True)
        plt.xlim(0., 200.)
        plt.ylabel('Probability')
        plt.xlabel('Inter-Spike Interval (ms)')
        plt.title('Distribution of Input Inter-Spike Intervals - '+title)
        plt.show()
        plt.close()
        peak_locs = [sim.attrs['peak_loc'] for sim in f.values()[0]['train'].values()]
        plt.hist(peak_locs, bins=bins)
        plt.xlabel('Time (ms)')
        plt.ylabel('Count (20 ms Bins)')
        plt.title('Distribution of Input Peak Locations - '+title)
        plt.xlim((np.min(peak_locs), np.max(peak_locs)))
        plt.show()
        plt.close()
        for sim in f.values():
            t = np.arange(0., duration, dt)
            vm = np.interp(t, sim['time'], sim['rec']['0'])
            start = int((equilibrate + track_equilibrate)/dt)
            plt.plot(np.subtract(t[start:], equilibrate + track_equilibrate), vm[start:])
            plt.xlabel('Time (ms)')
            plt.ylabel('Voltage (mV)')
            plt.title('Somatic Vm - '+title)
            plt.ylim((-70., -50.))
        plt.show()
        plt.close()
    rec_t = np.arange(0., track_duration, dt)
    spikes_removed = get_removed_spikes(rec_filename, plot=0)
    # down_sample traces to 2 kHz after clipping spikes for theta and ramp filtering
    down_dt = 0.5
    down_t = np.arange(0., track_duration, down_dt)
    # 2000 ms Hamming window, ~3 Hz low-pass for ramp, ~5 - 10 Hz bandpass for theta
    window_len = int(2000./down_dt)
    theta_filter = signal.firwin(window_len, [5., 10.], nyq=1000./2./down_dt, pass_zero=False)
    ramp_filter = signal.firwin(window_len, 3., nyq=1000./2./down_dt)
    theta_traces = []
    theta_removed = []
    ramp_traces = []
    ramp_removed = []
    intra_psd = []
    for trace in spikes_removed:
        intra_freq, this_intra_psd = signal.periodogram(trace, 1000./dt)
        intra_psd.append(this_intra_psd)
        #counts, vals = np.histogram(trace, bins=(np.max(trace)-np.min(trace))/0.2)
        #offset = vals[np.where(counts == np.max(counts))[0][0]]
        subtracted = trace # - offset
        down_sampled = np.interp(down_t, rec_t, subtracted)
        filtered = signal.filtfilt(theta_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        theta_traces.append(up_sampled)
        theta_filtered = subtracted - up_sampled
        theta_removed.append(theta_filtered)
        down_sampled = np.interp(down_t, rec_t, theta_filtered)
        filtered = signal.filtfilt(ramp_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        ramp_traces.append(up_sampled)
        ramp_filtered = theta_filtered - up_sampled
        ramp_removed.append(ramp_filtered)
    intra_psd = np.mean(intra_psd, axis=0)
    left = np.where(intra_freq >= 4.)[0][0]
    right = np.where(intra_freq >= 11.)[0][0]
    intra_psd /= np.max(intra_psd[left:right])
    mean_across_trials = np.mean(theta_removed, axis=0)
    variance_across_trials = np.var(theta_removed, axis=0)
    binned_mean = []
    binned_variance = []
    bin_duration = 250.
    interval = int(bin_duration/dt)
    for i, residual in enumerate(ramp_removed):
        for j in range(0, int(track_duration/bin_duration) - 1):
            binned_variance.append(np.var(residual[j*interval:(j+1)*interval]))
            binned_mean.append(np.mean(theta_removed[i][j*interval:(j+1)*interval]))
    plt.plot(rec_t, mean_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Voltage (mV)')
    plt.title('Somatic Vm Mean - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.plot(rec_t, variance_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Somatic Vm Variance - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.scatter(binned_mean, binned_variance)
    plt.xlabel('Mean Vm (mV)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Mean - Variance Analysis - ' + title)
    plt.show()
    plt.close()
    plt.plot(pop_freq, pop_psd, label='Total Population Input Spikes')
    plt.plot(intra_freq, intra_psd, label='Single Cell Intracellular Vm')
    plt.xlim(4., 11.)
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Normalized Power Density')
    plt.title('Power Spectral Density - ' + title)
    plt.legend(loc='best')
    plt.show()
    plt.close()
    return rec_t, ramp_removed, binned_mean, binned_variance


def process_simple_input_simulation(rec_filename, title, dt=0.02):
    """

    :param rec_file_name: str
    :param title: str
    # remember .attrs['phase_offset'] could be inside ['train'] for old files
    """
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        sim = f.values()[0]
        equilibrate = sim.attrs['equilibrate']
        track_equilibrate = sim.attrs['track_equilibrate']
        track_length = sim.attrs['track_length']
        input_field_duration = sim.attrs['input_field_duration']
        duration = sim.attrs['duration']
        stim_dt = sim.attrs['stim_dt']
        bins = int((1.5 + track_length) * input_field_duration / 20.)
        track_duration = duration - equilibrate - track_equilibrate
        stim_t = np.arange(-track_equilibrate, track_duration, stim_dt)
        intervals = []
        for sim in f.values():
            for train in sim['train'].values():
                if len(train) > 0:
                    for i in range(len(train) - 1):
                        intervals.append(train[i+1] - train[i])
        pop_input = [get_binned_firing_rate(sim['train'].values(), stim_t) for sim in f.values()]
        pop_psd = []
        for this_pop_input in pop_input:
            pop_freq, this_pop_psd = signal.periodogram(this_pop_input, 1000./stim_dt)
            pop_psd.append(this_pop_psd)
        pop_psd = np.mean(pop_psd, axis=0)
        left = np.where(pop_freq >= 4.)[0][0]
        right = np.where(pop_freq >= 11.)[0][0]
        pop_psd /= np.max(pop_psd[left:right])
        mean_input = np.mean(pop_input, axis=0)
        if 'successes' in f.values()[0]:
            successes = [get_binned_firing_rate(sim['successes'].values(), stim_t) for sim in f.values()]
            mean_successes = np.mean(successes, axis=0)
        if 'inh_train' in f.values()[0]:
            inh_input = [get_binned_firing_rate(sim['inh_train'].values(), stim_t) for sim in f.values()]
            mean_inh_input = np.mean(inh_input, axis=0)
        start = int(track_equilibrate/stim_dt)
        fig, axes = plt.subplots(2, 1)
        axes[0].plot(stim_t[start:], mean_input[start:], label='Total Excitatory Input Spike Rate', c='b')
        if 'successes' in f.values()[0]:
            axes[0].plot(stim_t[start:], mean_successes[start:], label='Total Excitatory Input Success Rate', c='g')
        if 'inh_train' in f.values()[0]:
            axes[1].plot(stim_t[start:], mean_inh_input[start:], label='Total Inhibitory Input Spike Rate', c='k')
        for ax in axes:
            ax.legend(loc='upper left', frameon=False, framealpha=0.5)
        axes[1].set_xlabel('Time (ms)')
        axes[1].set_ylabel('Event Rate (Hz)')
        axes[0].set_title(title)
        plt.show()
        plt.close()
        plt.hist(intervals, bins=int(max(intervals)/3.), normed=True)
        plt.xlim(0., 200.)
        plt.ylabel('Probability')
        plt.xlabel('Inter-Spike Interval (ms)')
        plt.title('Distribution of Input Inter-Spike Intervals - '+title)
        plt.show()
        plt.close()
        peak_locs = [sim.attrs['peak_loc'] for sim in f.values()[0]['train'].values()]
        plt.hist(peak_locs, bins=bins)
        plt.xlabel('Time (ms)')
        plt.ylabel('Count (20 ms Bins)')
        plt.title('Distribution of Input Peak Locations - '+title)
        plt.xlim((np.min(peak_locs), np.max(peak_locs)))
        plt.show()
        plt.close()
        for sim in f.values():
            t = np.arange(0., duration, dt)
            vm = np.interp(t, sim['time'], sim['rec']['0'])
            start = int((equilibrate + track_equilibrate)/dt)
            plt.plot(np.subtract(t[start:], equilibrate + track_equilibrate), vm[start:])
            plt.xlabel('Time (ms)')
            plt.ylabel('Voltage (mV)')
            plt.title('Somatic Vm - '+title)
            plt.ylim((-70., -50.))
        plt.show()
        plt.close()
    rec_t = np.arange(0., track_duration, dt)
    spikes_removed = get_removed_spikes(rec_filename, plot=0)
    # down_sample traces to 2 kHz after clipping spikes for theta and ramp filtering
    down_dt = 0.5
    down_t = np.arange(0., track_duration, down_dt)
    # 2000 ms Hamming window, ~3 Hz low-pass for ramp, ~5 - 10 Hz bandpass for theta
    window_len = int(2000./down_dt)
    theta_filter = signal.firwin(window_len, [5., 10.], nyq=1000./2./down_dt, pass_zero=False)
    ramp_filter = signal.firwin(window_len, 3., nyq=1000./2./down_dt)
    theta_traces = []
    theta_removed = []
    ramp_traces = []
    ramp_removed = []
    intra_psd = []
    for trace in spikes_removed:
        intra_freq, this_intra_psd = signal.periodogram(trace, 1000./dt)
        intra_psd.append(this_intra_psd)
        #counts, vals = np.histogram(trace, bins=(np.max(trace)-np.min(trace))/0.2)
        #offset = vals[np.where(counts == np.max(counts))[0][0]]
        subtracted = trace # - offset
        down_sampled = np.interp(down_t, rec_t, subtracted)
        filtered = signal.filtfilt(theta_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        theta_traces.append(up_sampled)
        theta_filtered = subtracted - up_sampled
        theta_removed.append(theta_filtered)
        down_sampled = np.interp(down_t, rec_t, theta_filtered)
        filtered = signal.filtfilt(ramp_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        ramp_traces.append(up_sampled)
        ramp_filtered = theta_filtered - up_sampled
        ramp_removed.append(ramp_filtered)
    intra_psd = np.mean(intra_psd, axis=0)
    left = np.where(intra_freq >= 4.)[0][0]
    right = np.where(intra_freq >= 11.)[0][0]
    intra_psd /= np.max(intra_psd[left:right])
    mean_across_trials = np.mean(theta_removed, axis=0)
    variance_across_trials = np.var(theta_removed, axis=0)
    binned_mean = []
    binned_variance = []
    bin_duration = 250.
    interval = int(bin_duration/dt)
    for i, residual in enumerate(ramp_removed):
        for j in range(0, int(track_duration/bin_duration) - 1):
            binned_variance.append(np.var(residual[j*interval:(j+1)*interval]))
            binned_mean.append(np.mean(theta_removed[i][j*interval:(j+1)*interval]))
    plt.plot(rec_t, mean_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Voltage (mV)')
    plt.title('Somatic Vm Mean - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.plot(rec_t, variance_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Somatic Vm Variance - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.scatter(binned_mean, binned_variance)
    plt.xlabel('Mean Vm (mV)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Mean - Variance Analysis - ' + title)
    plt.show()
    plt.close()
    plt.plot(pop_freq, pop_psd, label='Total Population Input Spikes')
    plt.plot(intra_freq, intra_psd, label='Single Cell Intracellular Vm')
    plt.xlim(4., 11.)
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Normalized Power Density')
    plt.title('Power Spectral Density - ' + title)
    plt.legend(loc='best')
    plt.show()
    plt.close()
    return binned_mean, binned_variance


def plot_spike_phase_precession(rec_filename, title):
    """

    :param rec_file_name: str
    :param title: str
    # remember .attrs['phase_offset'] could be inside ['train'] for old files
    """
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        equilibrate = f['0'].attrs['equilibrate']
        track_equilibrate = f['0'].attrs['track_equilibrate']
        track_length = f['0'].attrs['track_length']
        input_field_duration = f['0'].attrs['input_field_duration']
        duration = f['0'].attrs['duration']
        stim_dt = f['0'].attrs['stim_dt']
        bins = int((1.5 + track_length) * input_field_duration / 20.)
        track_duration = duration - equilibrate - track_equilibrate
        stim_t = np.arange(-track_equilibrate, track_duration, stim_dt)
        intervals = []
        for sim in f.values():
            for train in sim['train'].values():
                if len(train) > 0:
                    for i in range(len(train) - 1):
                        intervals.append(train[i+1] - train[i])
        pop_input = [get_binned_firing_rate(sim['train'].values(), stim_t) for sim in f.values()]
        pop_psd = []
        for this_pop_input in pop_input:
            pop_freq, this_pop_psd = signal.periodogram(this_pop_input, 1000./stim_dt)
            pop_psd.append(this_pop_psd)
        pop_psd = np.mean(pop_psd, axis=0)
        left = np.where(pop_freq >= 4.)[0][0]
        right = np.where(pop_freq >= 11.)[0][0]
        pop_psd /= np.max(pop_psd[left:right])
        mean_input = np.mean(pop_input, axis=0)
        if 'successes' in f['0']:
            successes = [get_binned_firing_rate(sim['successes'].values(), stim_t) for sim in f.values()]
            mean_successes = np.mean(successes, axis=0)
        if 'inh_train' in f['0']:
            inh_input = [get_binned_firing_rate(sim['inh_train'].values(), stim_t) for sim in f.values()]
            mean_inh_input = np.mean(inh_input, axis=0)
        output = [get_smoothed_firing_rate([sim['output']], stim_t) for sim in f.values()]
        mean_output = np.mean(output, axis=0)
        start = int(track_equilibrate/stim_dt)
        fig, axes = plt.subplots(3, 1)
        axes[0].plot(stim_t[start:], mean_input[start:], label='Total Excitatory Input Spike Rate', c='b')
        if 'successes' in f['0']:
            axes[0].plot(stim_t[start:], mean_successes[start:], label='Total Excitatory Input Success Rate', c='g')
        if 'inh_train' in f['0']:
            axes[1].plot(stim_t[start:], mean_inh_input[start:], label='Total Inhibitory Input Spike Rate', c='k')
        axes[2].plot(stim_t[start:], mean_output[start:], label='Single Cell Output Spike Rate', c='r')
        for ax in axes:
            ax.legend(loc='upper left', frameon=False, framealpha=0.5)
        axes[2].set_xlabel('Time (ms)')
        axes[1].set_ylabel('Event Rate (Hz)')
        axes[0].set_title(title)
        plt.show()
        plt.close()
        plt.hist(intervals, bins=int(max(intervals)/3.), normed=True)
        plt.xlim(0., 200.)
        plt.ylabel('Probability')
        plt.xlabel('Inter-Spike Interval (ms)')
        plt.title('Distribution of Input Inter-Spike Intervals - '+title)
        plt.show()
        plt.close()
        peak_locs = [sim.attrs['peak_loc'] for sim in f['0']['train'].values()]
        plt.hist(peak_locs, bins=bins)
        plt.xlabel('Time (ms)')
        plt.ylabel('Count (20 ms Bins)')
        plt.title('Distribution of Input Peak Locations - '+title)
        plt.xlim((np.min(peak_locs), np.max(peak_locs)))
        plt.show()
        plt.close()
        for sim in f.values():
            t = np.arange(0., duration, dt)
            vm = np.interp(t, sim['time'], sim['rec']['0'])
            start = int((equilibrate + track_equilibrate)/dt)
            plt.plot(np.subtract(t[start:], equilibrate + track_equilibrate), vm[start:])
            plt.xlabel('Time (ms)')
            plt.ylabel('Voltage (mV)')
            plt.title('Somatic Vm - '+title)
            plt.ylim((-70., -50.))
        plt.show()
        plt.close()
    rec_t = np.arange(0., track_duration, dt)
    spikes_removed = get_removed_spikes(rec_filename, plot=0)
    # down_sample traces to 2 kHz after clipping spikes for theta and ramp filtering
    down_dt = 0.5
    down_t = np.arange(0., track_duration, down_dt)
    # 2000 ms Hamming window, ~3 Hz low-pass for ramp, ~5 - 10 Hz bandpass for theta
    window_len = int(2000./down_dt)
    theta_filter = signal.firwin(window_len, [5., 10.], nyq=1000./2./down_dt, pass_zero=False)
    ramp_filter = signal.firwin(window_len, 3., nyq=1000./2./down_dt)
    theta_traces = []
    theta_removed = []
    ramp_traces = []
    ramp_removed = []
    intra_psd = []
    for trace in spikes_removed:
        intra_freq, this_intra_psd = signal.periodogram(trace, 1000./dt)
        intra_psd.append(this_intra_psd)
        #counts, vals = np.histogram(trace, bins=(np.max(trace)-np.min(trace))/0.2)
        #offset = vals[np.where(counts == np.max(counts))[0][0]]
        subtracted = trace # - offset
        down_sampled = np.interp(down_t, rec_t, subtracted)
        filtered = signal.filtfilt(theta_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        theta_traces.append(up_sampled)
        theta_filtered = subtracted - up_sampled
        theta_removed.append(theta_filtered)
        down_sampled = np.interp(down_t, rec_t, theta_filtered)
        filtered = signal.filtfilt(ramp_filter, [1.], down_sampled, padtype='even', padlen=window_len)
        up_sampled = np.interp(rec_t, down_t, filtered)
        ramp_traces.append(up_sampled)
        ramp_filtered = theta_filtered - up_sampled
        ramp_removed.append(ramp_filtered)
    intra_psd = np.mean(intra_psd, axis=0)
    left = np.where(intra_freq >= 4.)[0][0]
    right = np.where(intra_freq >= 11.)[0][0]
    intra_psd /= np.max(intra_psd[left:right])
    mean_across_trials = np.mean(theta_removed, axis=0)
    variance_across_trials = np.var(theta_removed, axis=0)
    binned_mean = []
    binned_variance = []
    bin_duration = 250.
    interval = int(bin_duration/dt)
    for i, residual in enumerate(ramp_removed):
        for j in range(0, int(track_duration/bin_duration) - 1):
            binned_variance.append(np.var(residual[j*interval:(j+1)*interval]))
            binned_mean.append(np.mean(theta_removed[i][j*interval:(j+1)*interval]))
    plt.plot(rec_t, mean_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Voltage (mV)')
    plt.title('Somatic Vm Mean - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.plot(rec_t, variance_across_trials)
    plt.xlabel('Time (ms)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Somatic Vm Variance - Across Trials - ' + title)
    plt.show()
    plt.close()
    plt.scatter(binned_mean, binned_variance)
    plt.xlabel('Mean Vm (mV)')
    plt.ylabel('Vm Variance (mV'+r'$^2$'+')')
    plt.title('Mean - Variance Analysis - ' + title)
    plt.show()
    plt.close()
    plt.plot(pop_freq, pop_psd, label='Total Population Input Spikes')
    plt.plot(intra_freq, intra_psd, label='Single Cell Intracellular Vm')
    plt.xlim(4., 11.)
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Normalized Power Density')
    plt.title('Power Spectral Density - ' + title)
    plt.legend(loc='best')
    plt.show()
    plt.close()
    return binned_mean, binned_variance


def plot_phase_precession(t_array, phase_array, title):
    """

    :param t_array: list of np.array
    :param phase_array: list of np.array
    :param title: str
    """
    colors = plt.cm.rainbow(np.linspace(0, 1, len(t_array)))
    for i, t in enumerate(t_array):
        phases = phase_array[i]
        m, b = np.polyfit(t, phases, 1)
        plt.scatter(t, phases, c=colors[i])
        fit_t = np.arange(np.min(t), np.max(t), 10.)
        plt.plot(fit_t, m * fit_t + b, c=colors[i])
    plt.ylim(0., 360.)
    plt.ylabel('Phase ($^\circ$)')
    plt.xlabel('Time (ms)')
    plt.title('Phase Precession - '+ title)
    plt.show()
    plt.close()


def process_simple_axon_model_output(rec_filename, stim_list=[-0.05, -0.1, -0.15, -0.2, -0.25, 0.2, 0.4, 0.6, 0.8, 1.]):
    """

    :param rec_filename: str
    :param stim_list: list of int
    :return: min_voltages: dict
    """
    dt = 0.01
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        if 'duration' in f['0'].attrs:
            duration = f['0'].attrs['duration']
        else:
            duration = 400.
        if 'equilibrate' in f['0'].attrs:
            equilibrate = f['0'].attrs['equilibrate']
        else:
            equilibrate = 250.
        if 'stim_dur' in f['0'].attrs:
            stim_dur = f['0'].attrs['stim_dur']
        else:
            stim_dur = 50.
        t = np.arange(0., duration, dt)
        left = int((equilibrate-3.) / dt)
        right = int((equilibrate-1.) / dt)
        start = int((equilibrate+stim_dur-11.) / dt)
        end = int((equilibrate+stim_dur-1.) / dt)
        min_voltages = {stim: [] for stim in stim_list}
        for i, sim in enumerate(f.values()):
            for rec in sim['rec'].values():
                vm = np.interp(t, sim['time'], rec)
                baseline = np.mean(vm[left:right])
                min_voltage = np.min(vm[start:end]) - baseline
                min_voltages[stim_list[i]].append(min_voltage)
    return min_voltages


def get_spike_delay_vs_distance_simple_axon_model(rec_filename):
    """

    :param rec_filename:
    :return: distances, delays
    """
    dt = 0.01
    th_dvdt = 20.
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        if 'duration' in f['0'].attrs:
            duration = f['0'].attrs['duration']
        else:
            duration = 400.
        if 'equilibrate' in f['0'].attrs:
            equilibrate = f['0'].attrs['equilibrate']
        else:
            equilibrate = 250.
        if 'stim_dur' in f['0'].attrs:
            stim_dur = f['0'].attrs['stim_dur']
        else:
            stim_dur = 50.
        t = np.arange(0., duration, dt)
        start = int((equilibrate+0.4) / dt)
        end = int((equilibrate+stim_dur) / dt)
        distances = []
        delays = []
        for sim in f.values():
            if not distances:
                for rec in sim['rec'].values():
                    distances.append(rec.attrs['soma_distance'])
            if sim['stim']['0'].attrs['amp'] > 0.:
                rec = sim['rec']['0']
                vm = np.interp(t, sim['time'], rec)
                dvdt = np.gradient(vm, [dt])
                th_x = np.where(dvdt[start:end] > th_dvdt)[0]
                if th_x.any():
                    soma_th_x = th_x[0] + start
                    end = soma_th_x + int(5. / dt)
                    soma_peak = np.max(vm[soma_th_x:end])
                    soma_peak_x = np.where(vm[soma_th_x:end]==soma_peak)[0][0] + soma_th_x
                    soma_peak_t = t[soma_peak_x]
                    start = soma_th_x - int(2. / dt)
                    for rec in sim['rec'].values():
                        vm = np.interp(t, sim['time'], rec)
                        peak = np.max(vm[start:end])
                        peak_x = np.where(vm[start:end]==peak)[0][0] + start
                        peak_t = t[peak_x]
                        delay = peak_t - soma_peak_t
                        delays.append(delay)
                    break
    return distances, delays