__author__ = 'milsteina'
from function_lib import *
import numpy as np


def plot_AR(rec_filename):
    """
    Plots a graph of Amplitude Ratio (spine to branch) vs. distance from primary branch for each dendritic sec_type.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    AR = {}
    dendR = {}
    neckR = {}
    amp = f['0'].attrs['amp']
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == 'spine':
            spine_stim = f[str(simiter)]['rec']
            spine_tvec = f[str(simiter)]['time']
            branch_stim = f[str(simiter+1)]['rec']
            branch_tvec = f[str(simiter+1)]['time']
        elif f[str(simiter)].attrs['stim_loc'] == 'branch':
            spine_stim = f[str(simiter+1)]['rec']
            spine_tvec = f[str(simiter+1)]['time']
            branch_stim = f[str(simiter)]['rec']
            branch_tvec = f[str(simiter)]['time']
        for rec in spine_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            AR[sec_type] = []
            dendR[sec_type] = []
            neckR[sec_type] = []
        distances[sec_type].append(branch_rec.attrs['branch_distance'])
        left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        baseline_spine = np.average(spine_rec[left:right])
        left, right = time2index(spine_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        peak_spine = np.max(spine_rec[left:right]) - baseline_spine
        this_AR = peak_spine / peak_branch
        AR[sec_type].append(this_AR)
        for rec in branch_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                break
        left, right = time2index(branch_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        left, right = time2index(branch_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        this_dendR = peak_branch / amp
        dendR[sec_type].append(this_dendR)
        this_neckR = (this_AR - 1) * this_dendR
        neckR[sec_type].append(this_neckR)
        simiter += 2
    fig, axes = plt.subplots(3, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(AR[sec_type].__getitem__, indexes), marker='o', color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Amplitude Ratio')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(dendR[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('R_Dend (MOhm)')
        axes[1][i].set_title(sec_type)
        axes[2][i].scatter(sorted_distances[sec_type], map(neckR[sec_type].__getitem__, indexes), marker='v',
                                                                                            color=color)
        axes[2][i].set_xlabel('Location (um)')
        axes[2][i].set_ylabel('R_Neck (MOhm)')
        axes[2][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.5)
    plt.show()
    plt.close()
    f.close()


def plot_spine_amp(rec_filename):
    """
    Plots a graph of spine EPSP amp and branch EPSP amp vs. distance from primary branch for each dendritic sec_type.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    spine_amp = {}
    branch_amp = {}
    #amp = f['0'].attrs['amp']
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == 'spine':
            spine_stim = f[str(simiter)]['rec']
            spine_tvec = f[str(simiter)]['time']
        elif f[str(simiter)].attrs['stim_loc'] == 'branch':
            spine_stim = f[str(simiter+1)]['rec']
            spine_tvec = f[str(simiter+1)]['time']
        for rec in spine_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            spine_amp[sec_type] = []
            branch_amp[sec_type] = []
        distances[sec_type].append(branch_rec.attrs['branch_distance'])
        left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        baseline_spine = np.average(spine_rec[left:right])
        left, right = time2index(spine_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        peak_spine = np.max(spine_rec[left:right]) - baseline_spine
        spine_amp[sec_type].append(peak_spine)
        branch_amp[sec_type].append(peak_branch)
        simiter += 2
    fig, axes = plt.subplots(2, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(spine_amp[sec_type].__getitem__, indexes), marker='o',
                           color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Spine Amp (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(branch_amp[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('Branch Amp (mV)')
        axes[1][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_spine_Vm(rec_filename, stim_loc='spine'):
    """
    Plots traces from either spine or branch stim. Superimposes all traces from a dendritic sec type. Separates spine
    voltage from branch voltage.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    :param stim_loc: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    fig, axes = plt.subplots(2, 4)
    colors = ['b', 'g', 'r', 'c']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter)]['rec']
            tvec = f[str(simiter)]['time']
        elif f[str(simiter+1)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter+1)]['rec']
            tvec = f[str(simiter+1)]['time']
        for rec in stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
        left, right = time2index(tvec[:], equilibrate-5.0, duration)
        i = sec_types.index(sec_type)
        #color = colors[i]
        axes[0][i].plot(tvec[left:right], spine_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Spine Vm (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].plot(tvec[left:right], branch_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Branch Vm (mV)')
        axes[0][i].set_title(sec_type)
        simiter += 2
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_Rinp(rec_filename):
    """
    Produces a plot of input resistance vs. distance from primary branch for each dendritic subtype.
    Expects .hdf5 files generated by test_rinp.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    peak = {}
    steady = {}
    sag = {}
    amp = f['0']['stim']['0'].attrs['amp']
    start = f['0']['stim']['0'].attrs['delay']
    stop = start + f['0']['stim']['0'].attrs['dur']
    #simiter = 0
    for sim in f.itervalues():
        rec = sim['rec']['0']
        sec_type = rec.attrs['type']
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            peak[sec_type] = []
            steady[sec_type] = []
            sag[sec_type] = []
        distances[sec_type].append(rec.attrs['branch_distance'])
        tvec = sim['time']
        this_peak, this_steady = get_Rinp(tvec[:], rec[:], start, stop, amp)
        peak[sec_type].append(this_peak)
        steady[sec_type].append(this_steady)
        sag[sec_type].append(100*(1-this_steady/this_peak))
    rowlen = len(sec_types)
    fig, axes = plt.subplots(3, rowlen)
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(peak[sec_type].__getitem__, indexes), marker='o',
                           color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Input Resistance - Peak (MOhm)')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(steady[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('Input Resistance - Steady-state (MOhm)')
        axes[1][i].set_title(sec_type)
        axes[2][i].scatter(sorted_distances[sec_type], map(sag[sec_type].__getitem__, indexes), marker='v',
                                                                                            color=color)
        axes[2][i].set_xlabel('Location (um)')
        axes[2][i].set_ylabel('% Sag')
        axes[2][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_superimpose_conditions(rec_filename):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if ('description' in sim.attrs) and not (sim.attrs['description'] in sim_ids):
            sim_ids.append(sim.attrs['description'])
    for rec in f['0']['rec'].itervalues():
        if ('description' in rec.attrs):
            rec_id = rec.attrs['description']
        else:
            rec_id = rec.attrs['type']+str(rec.attrs['index'])
        if not rec_id in (id['id'] for id in rec_ids):
            rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    if len(rec_ids) > 1:
        fig, axes = plt.subplots(1, len(rec_ids))
    else:
        fig, ax = plt.subplots(1, 1)
        axes = [ax]
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for simiter in f:
        if 'description' in f[simiter].attrs:
            sim_id = f[simiter].attrs['description']
        else:
            sim_id = ''
        tvec = f[simiter]['time']
        for rec in f[simiter]['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    for i in range(len(rec_ids)):
        axes[i].legend(loc='best')
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_attenuation(rec_filename):
    """
    Produces a grid of 12 plots of AMPAR EPSP amplitude vs. distance. Shows 4 recording locations (spine, branch, trunk,
    soma) for 4 spine locations (basal, trunk, apical, tuft).
    Expects .hdf5 files generated by test_EPSP_attenuation.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    input_locs = []
    rec_locs = []
    distances = {}
    sorted_distances = {}
    amps = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    for sim in f.itervalues():
        input_loc = sim.attrs['input_loc']
        # input_loc = sim['rec']['2'].attrs['type']
        if not input_loc in input_locs:
            input_locs.append(input_loc)
            distances[input_loc] = []
            amps[input_loc] = {}
        tvec = sim['time']
        distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
        for rec in sim['rec'].itervalues():
            rec_loc = rec.attrs['description']
            if not rec_loc in rec_locs:
                rec_locs.append(rec_loc)
            if not rec_loc in amps[input_loc]:
                amps[input_loc][rec_loc] = []
            left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
            baseline = np.average(rec[left:right])
            left, right = time2index(tvec[:], equilibrate, duration)
            amps[input_loc][rec_loc].append(np.max(rec[left:right]) - baseline)
    fig, axes = plt.subplots(len(input_locs), len(rec_locs))
    #fig, axes = plt.subplots(1, len(amps[amps.keys()[0]]))
    colors = ['b', 'g', 'r', 'c']
    for i, input_loc in enumerate(input_locs):
        indexes = range(len(distances[input_loc]))
        indexes.sort(key=distances[input_loc].__getitem__)
        sorted_distances[input_loc] = map(distances[input_loc].__getitem__, indexes)
        for j, rec_loc in enumerate(rec_locs):
            color = colors[j]
            axes[i][j].scatter(sorted_distances[input_loc], map(amps[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes[i][j].set_xlabel('Location (um)')
            axes[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Amp (mV)')
            axes[i][j].set_title('Recording Loc: '+rec_loc)
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_kinetics(rec_filename):
    """
    Produces a grid of 12 plots of AMPAR EPSP kinetics vs. distance. Shows 4 recording locations (spine, branch, trunk,
    soma) for 4 spine locations (basal, trunk, apical, tuft).
    Produces one plot each for rise kinetics and decay kinetics.
    Expects .hdf5 files generated by test_EPSP_attenuation.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    input_locs = []
    rec_locs = []
    distances = {}
    sorted_distances = {}
    rise_taus = {}
    decay_taus = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    for sim in f.itervalues():
        input_loc = sim.attrs['input_loc']
        if not input_loc in input_locs:
            input_locs.append(input_loc)
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
        tvec = sim['time']
        distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
        for rec in sim['rec'].itervalues():
            rec_loc = rec.attrs['description']
            if not rec_loc in rec_locs:
                rec_locs.append(rec_loc)
            if not rec_loc in rise_taus[input_loc]:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
            left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
            baseline = np.average(rec[left:right])
            left, right = time2index(tvec[:], equilibrate, duration)
            y = rec[left:right] - baseline
            t = tvec[left:right]
            t -= t[0]
            amp = np.max(y)
            y /= amp
            fit_amp, fit_rise, fit_decay = fit_exp_nonlinear(t, y, -5., -10.)
            rise_taus[input_loc][rec_loc].append(-1.*fit_rise)
            decay_taus[input_loc][rec_loc].append(-1*fit_decay)
    fig1, axes1 = plt.subplots(len(input_locs), len(rec_locs))
    fig2, axes2 = plt.subplots(len(input_locs), len(rec_locs))
    colors = ['b', 'g', 'r', 'c']
    for i, input_loc in enumerate(input_locs):
        indexes = range(len(distances[input_loc]))
        indexes.sort(key=distances[input_loc].__getitem__)
        sorted_distances[input_loc] = map(distances[input_loc].__getitem__, indexes)
        for j, rec_loc in enumerate(rec_locs):
            color = colors[j]
            axes1[i][j].scatter(sorted_distances[input_loc], map(rise_taus[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes1[i][j].set_xlabel('Location (um)')
            axes1[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Rise Tau (ms)')
            axes1[i][j].set_title('Recording Loc: '+rec_loc)
            axes2[i][j].scatter(sorted_distances[input_loc], map(decay_taus[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes2[i][j].set_xlabel('Location (um)')
            axes2[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Decay Tau (ms)')
            axes2[i][j].set_title('Recording Loc: '+rec_loc)
    fig1.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    #fig1.show()
    #fig2.show()
    plt.show()
    plt.close()
    f.close()