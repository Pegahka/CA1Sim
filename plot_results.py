__author__ = 'milsteina'
from function_lib import *
import matplotlib.lines as mlines
import numpy as np


def plot_AR(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_spine_attenuation_ratio.
    Files contain voltage recordings from spine and branch probed with EPSC-shaped current injections to measure spine
    to branch EPSP amplitude attenuation ratio, dendritic branch impedance, and spine neck resistance. Plots these
    parameters vs distance from dendrite origin, with one column per dendritic sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in [sim for sim in f.itervalues() if sim.attrs['stim_loc'] == 'spine']:
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    AR = {}
    dendR = {}
    neckR = {}
    fig, axes = plt.subplots(3, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        for sec_type in sec_types:
            distances[sec_type] = []
            AR[sec_type] = []
            dendR[sec_type] = []
            neckR[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0'].attrs['amp']
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                spine_tvec = f[indices['spine']]['time']
                branch_stim = f[indices['branch']]['rec']
                branch_tvec = f[indices['branch']]['time']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        branch_rec = rec
                        sec_type = rec.attrs['type']
                    elif rec.attrs['description'] == 'spine':
                        spine_rec = rec
                distances[sec_type].append(branch_rec.attrs['branch_distance'])
                interp_t = np.arange(0, duration, 0.001)
                interp_branch_vm = np.interp(interp_t, spine_tvec[:], branch_rec[:])
                interp_spine_vm = np.interp(interp_t, spine_tvec[:], spine_rec[:])
                left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(interp_branch_vm[left:right])
                baseline_spine = np.average(interp_spine_vm[left:right])
                left, right = time2index(interp_t, equilibrate, duration)
                peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                peak_spine = np.max(interp_spine_vm[left:right]) - baseline_spine
                this_AR = peak_spine / peak_branch
                AR[sec_type].append(this_AR)
                branch_rec = branch_stim['0'] if branch_stim['0'].attrs['description'] == 'branch' else branch_stim['1']
                interp_t = np.arange(0, duration, 0.001)
                interp_branch_vm = np.interp(interp_t, branch_tvec[:], branch_rec[:])
                left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(interp_branch_vm[left:right])
                left, right = time2index(interp_t, equilibrate, duration)
                peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                this_dendR = peak_branch / amp
                dendR[sec_type].append(this_dendR)
                this_neckR = (this_AR - 1) * this_dendR
                neckR[sec_type].append(this_neckR)
            for i, sec_type in enumerate(sec_types):
                axes[0][i].scatter(distances[sec_type], AR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[0][i].set_ylabel('Amplitude Ratio')
                axes[0][i].set_title(sec_type)
                axes[1][i].scatter(distances[sec_type], dendR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[1][i].set_ylabel('R_Dend (MOhm)')
                axes[1][i].set_title(sec_type)
                axes[2][i].scatter(distances[sec_type], neckR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[2][i].set_ylabel('R_Neck (MOhm)')
                axes[2][i].set_title(sec_type)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_AR_EPSP_amp(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_spine_attenuation.
    Files contain voltage recordings from spine and branch while injecting EPSC-shaped currents into either spine or
    branch to measure the amplitude attenuation ratio.
    Creates a grid of 16 plots of EPSP amp vs. time, with one row per dendritic sec_type and four columns containing all
    stimulation and recording conditions.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in [sim for sim in f.itervalues() if sim.attrs['stim_loc'] == 'spine']:
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    spine_amp = {'spine': {}, 'branch': {}}
    branch_amp = {'spine': {}, 'branch': {}}
    fig, axes = plt.subplots(max(2, len(sec_types)), 4)
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        for sec_type in sec_types:
            distances[sec_type] = []
            for stim_loc in ['spine', 'branch']:
                spine_amp[stim_loc][sec_type] = []
                branch_amp[stim_loc][sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0'].attrs['amp']
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        branch_rec = rec
                        sec_type = rec.attrs['type']
                distances[sec_type].append(branch_rec.attrs['branch_distance'])
                for stim_loc, stim, tvec in [(stim_loc, f[indices[stim_loc]]['rec'], f[indices[stim_loc]]['time'])
                                             for stim_loc in ['spine', 'branch']]:
                    for rec in stim.itervalues():
                        if rec.attrs['description'] == 'branch':
                            branch_rec = rec
                        else:
                            spine_rec = rec
                    interp_t = np.arange(0, duration, 0.001)
                    interp_branch_vm = np.interp(interp_t, tvec[:], branch_rec[:])
                    interp_spine_vm = np.interp(interp_t, tvec[:], spine_rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline_branch = np.average(interp_branch_vm[left:right])
                    baseline_spine = np.average(interp_spine_vm[left:right])
                    left, right = time2index(interp_t, equilibrate, duration)
                    peak_branch = np.max(interp_branch_vm[left:right]) - baseline_branch
                    peak_spine = np.max(interp_spine_vm[left:right]) - baseline_spine
                    spine_amp[stim_loc][sec_type].append(peak_spine)
                    branch_amp[stim_loc][sec_type].append(peak_branch)
            for i, sec_type in enumerate(sec_types):
                axes[i][0].scatter(distances[sec_type], branch_amp['branch'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][1].scatter(distances[sec_type], spine_amp['branch'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][2].scatter(distances[sec_type], branch_amp['spine'][sec_type], label=description_list[index],
                                   color=colors[index])
                axes[i][3].scatter(distances[sec_type], spine_amp['spine'][sec_type], label=description_list[index],
                                   color=colors[index])
    for i, sec_type in enumerate(sec_types):
        for j, label in enumerate(['Stim Branch - Record Branch', 'Stim Branch - Record Spine',
                                   'Stim Spine - Record Branch', 'Stim Spine - Record Spine']):
            axes[i][j].set_xlabel('Distance from Dendrite Origin (um)')
            axes[i][j].set_ylabel('Input Loc: '+sec_type+'\nEPSP Amplitude (mV)')
            axes[i][j].set_title(label)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_AR_vm(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_spine_attenuation.
    Files contain voltage recordings from spine and branch while injecting EPSC-shaped currents into either spine or
    branch to measure the amplitude attenuation ratio.
    Creates a grid of 16 plots of vm vs. time, with one row per dendritic sec_type and four columns containing all
    stimulation and recording conditions.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    fig, axes = plt.subplots(max(2, len(sec_types)), 4)
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        index_dict = {}
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            # following parallel execution and combine_rec_files, the order of simulation records is shuffled
            # here the indices of paired records from spine_stim and branch_stim are collected
            for simiter in f:
                sim = f[simiter]
                stim_loc = sim.attrs['stim_loc']
                spine_rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'spine' else sim['rec']['1']
                spine_index = spine_rec.attrs['index']
                if not spine_index in index_dict:
                    index_dict[spine_index] = {}
                index_dict[spine_index][stim_loc] = simiter
            for indices in index_dict.itervalues():
                spine_stim = f[indices['spine']]['rec']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        sec_type = rec.attrs['type']
                for stim_loc, stim, tvec in [(stim_loc, f[indices[stim_loc]]['rec'], f[indices[stim_loc]]['time'])
                                             for stim_loc in ['spine', 'branch']]:
                    for rec in stim.itervalues():
                        if rec.attrs['description'] == 'branch':
                            branch_rec = rec
                        else:
                            spine_rec = rec
                    j = 0 if stim_loc == 'branch' else 2
                    i = sec_types.index(sec_type)
                    interp_t = np.arange(0, duration, 0.01)
                    interp_branch_vm = np.interp(interp_t, tvec[:], branch_rec[:])
                    interp_spine_vm = np.interp(interp_t, tvec[:], spine_rec[:])
                    left, right = time2index(interp_t, equilibrate-5.0, duration)
                    interp_t -= interp_t[left] + 5.
                    axes[i][j].plot(interp_t[left:right], interp_branch_vm[left:right], color=colors[index])
                    axes[i][j+1].plot(interp_t[left:right], interp_spine_vm[left:right], color=colors[index])
    for i, sec_type in enumerate(sec_types):
        for j, label in enumerate(['Stim Branch - Record Branch', 'Stim Branch - Record Spine',
                                   'Stim Spine - Record Branch', 'Stim Spine - Record Spine']):
            axes[i][j].set_xlabel('Time (ms)')
            axes[i][j].set_ylabel('Input Loc: '+sec_type+'\nVm (mV)')
            axes[i][j].set_title(label)
    label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0][0].legend(handles=label_handles, framealpha=0.5, frameon=False)
    plt.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_Rinp(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections to
    measure 1) peak r_inp, 2) steady-state r_inp, 3) their ratio, and 4) v_rest. Plots these parameters vs distance from
    dendrite origin, with one column per sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    peak = {}
    steady = {}
    sag = {}
    v_rest = {}
    fig, axes = plt.subplots(4, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for sec_type in sec_types:
            distances[sec_type] = []
            peak[sec_type] = []
            steady[sec_type] = []
            sag[sec_type] = []
            v_rest[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0']['stim']['0'].attrs['amp']
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + f['0']['stim']['0'].attrs['dur']
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                distances[sec_type].append(rec.attrs['branch_distance'])
                tvec = sim['time']
                this_rest, this_peak, this_steady = get_Rinp(tvec[:], rec[:], start, stop, amp)
                peak[sec_type].append(this_peak)
                steady[sec_type].append(this_steady)
                sag[sec_type].append(100*(1-this_steady/this_peak))
                v_rest[sec_type].append(this_rest)
            for i, sec_type in enumerate(sec_types):
                axes[0][i].scatter(distances[sec_type], peak[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[0][i].set_ylabel('Input Resistance\nPeak (MOhm)')
                axes[0][i].set_title(sec_type)
                axes[1][i].scatter(distances[sec_type], steady[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[1][i].set_ylabel('Input Resistance\nSteady-state (MOhm)')
                axes[1][i].set_title(sec_type)
                axes[2][i].scatter(distances[sec_type], sag[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[2][i].set_ylabel('% Sag')
                axes[2][i].set_title(sec_type)
                axes[3][i].scatter(distances[sec_type], v_rest[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[3][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[3][i].set_ylabel('Resting Vm (mV)')
                axes[3][i].set_title(sec_type)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_Rinp_vm(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections.
    Plots vm vs. time,with one row per sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    fig, axes = plt.subplots(1, max(2, len(sec_types)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + f['0']['stim']['0'].attrs['dur']
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                i = sec_types.index(sec_type)
                tvec = sim['time']
                interp_t = np.arange(0, stop, 0.01)
                interp_vm = np.interp(interp_t, tvec[:], rec[:])
                left, right = time2index(interp_t, start-5.0, stop)
                interp_t -= interp_t[left] + 5.
                axes[i].plot(interp_t[left:right], interp_vm[left:right], color=colors[index])
            for i, sec_type in enumerate(sec_types):
                axes[i].set_xlabel('Time (ms)')
                axes[i].set_ylabel('Vm (mV)')
                axes[i].set_title(sec_type)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0].legend(handles=label_handles, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_superimpose_conditions(rec_filename, legend=True):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    :param legend: bool
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if 'description' in sim.attrs and not sim.attrs['description'] in sim_ids:
            sim_ids.append(sim.attrs['description'])
        for rec in sim['rec'].itervalues():
            if 'description' in rec.attrs:
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            if not rec_id in (id['id'] for id in rec_ids):
                rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    if len(rec_ids) > 1:
        fig, axes = plt.subplots(1, len(rec_ids))
    else:
        fig, ax = plt.subplots(1, 1)
        axes = [ax]
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for sim in f.itervalues():
        if 'description' in sim.attrs:
            sim_id = sim.attrs['description']
        else:
            sim_id = ''
        tvec = sim['time']
        for rec in sim['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    if legend:
        for i in range(len(rec_ids)):
            axes[i].legend(loc='best', framealpha=0.5, frameon=False)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_attenuation(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of 16 plots of EPSP amplitude vs. distance from dendrite origin.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    amps = {}
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            amps[input_loc] = {}
            for rec_loc in rec_locs:
                amps[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(rec[left:right])
                    left, right = time2index(tvec[:], equilibrate, duration)
                    amps[input_loc][rec_loc].append(np.max(rec[left:right]) - baseline)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].scatter(distances[input_loc], amps[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Amp (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_EPSP_kinetics(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces a grid of 16 plots of EPSP kinetics vs. distance from dendrite origin.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    rise_taus = {}
    decay_taus = {}
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
            for rec_loc in rec_locs:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
                    interp_t = np.arange(0, duration, 0.001)
                    baseline = np.average(rec[left:right])
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    start, end = time2index(interp_t, equilibrate, duration)
                    interp_t = interp_t[start:end]
                    interp_vm = interp_vm[start:end] - baseline
                    amp = np.max(interp_vm)
                    t_peak = np.where(interp_vm == amp)[0][0]
                    interp_vm /= amp
                    interp_t -= interp_t[0]
                    rise_tau = optimize.curve_fit(model_exp_rise, interp_t[1:t_peak], interp_vm[1:t_peak], p0=0.3)[0]
                    decay_tau = optimize.curve_fit(model_exp_decay, interp_t[t_peak+1:]-interp_t[t_peak],
                                                   interp_vm[t_peak+1:], p0=5.)[0]
                    rise_taus[input_loc][rec_loc].append(rise_tau)
                    decay_taus[input_loc][rec_loc].append(decay_tau)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes1[i][j].scatter(distances[input_loc], rise_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes1[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes1[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Rise Tau (ms)')
                    axes1[i][j].set_title('Recording Loc: '+rec_loc)
                    axes2[i][j].scatter(distances[input_loc], decay_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes2[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes2[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Decay Tau (ms)')
                    axes2[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes1[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
        axes2[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig1.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_EPSP_i_attenuation(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces one figure containing a grid of 15 plots of EPSP amplitude vs. distance from soma.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    amps = {}
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            amps[input_loc] = {}
            for rec_loc in rec_locs:
                amps[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    if rec_loc == 'branch':
                        distances[input_loc].append(rec.attrs['soma_distance'])
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    start, end = time2index(interp_t, equilibrate, duration)
                    amps[input_loc][rec_loc].append(np.max(interp_vm[start:end]) - baseline)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].scatter(distances[input_loc], amps[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes[i][j].set_xlabel('Distance from Soma (um)')
                    axes[i][j].set_ylabel('Input Loc: '+input_loc+'\nEPSP Amp (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_EPSP_i_kinetics(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces a grid of 15 plots of EPSP kinetics vs. distance from soma.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    rise_taus = {}
    decay_taus = {}
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
            for rec_loc in rec_locs:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    if rec_loc == 'branch':
                        distances[input_loc].append(rec.attrs['soma_distance'])
                    interp_t = np.arange(0, duration, 0.001)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(interp_vm[left:right])
                    start, end = time2index(interp_t, equilibrate, duration)
                    interp_t = interp_t[start:end]
                    interp_vm = interp_vm[start:end] - baseline
                    amp = np.max(interp_vm)
                    t_peak = np.where(interp_vm == amp)[0][0]
                    interp_vm /= amp
                    interp_t -= interp_t[0]
                    rise_tau = optimize.curve_fit(model_exp_rise, interp_t[1:t_peak], interp_vm[1:t_peak], p0=0.3)[0]
                    decay_tau = optimize.curve_fit(model_exp_decay, interp_t[t_peak+1:]-interp_t[t_peak],
                                                   interp_vm[t_peak+1:], p0=5.)[0]
                    rise_taus[input_loc][rec_loc].append(rise_tau)
                    decay_taus[input_loc][rec_loc].append(decay_tau)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes1[i][j].scatter(distances[input_loc], rise_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes1[i][j].set_xlabel('Distance from Soma (um)')
                    axes1[i][j].set_ylabel('Input Loc: '+input_loc+'\nEPSP Rise Tau (ms)')
                    axes1[i][j].set_title('Recording Loc: '+rec_loc)
                    axes2[i][j].scatter(distances[input_loc], decay_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes2[i][j].set_xlabel('Distance from Soma (um)')
                    axes2[i][j].set_ylabel('Input Loc: '+input_loc+'\nEPSP Decay Tau (ms)')
                    axes2[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes1[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
        axes2[0][0].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    fig1.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_EPSP_i_vm(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_i_attenuation.
    Files contain simultaneous voltage recordings from 3 locations (soma, trunk, branch) during stimulation of a single
    branch with an EPSC-shaped current injection. Stimulated sec_types include (soma, basal, trunk, apical, tuft).
    Produces a grid of 15 plots of vm vs time, superimposing all responses with the same input and recording location.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['soma', 'basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    label_handles = []
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                i = input_locs.index(input_loc)
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    j = rec_locs.index(rec_loc)
                    interp_t = np.arange(0, duration, 0.01)
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    left, right = time2index(interp_t, equilibrate-5., equilibrate+50.)
                    interp_t -= interp_t[left] + 5.
                    axes[i][j].plot(interp_t[left:right], interp_vm[left:right], color=colors[index])
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].set_xlabel('Time (ms)')
                    axes[i][j].set_ylabel('Input Loc: '+input_loc+'\nVm (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
        label_handles.append(mlines.Line2D([], [], color=colors[index], label=description_list[index]))
    if not description_list == [""]:
        axes[0][0].legend(handles=label_handles, framealpha=0.5, frameon=False)
    fig.subplots_adjust(hspace=0.5, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_parameter(rec_file_list, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if description_list is None:
        description_list = ["" for rec in rec_file_list]
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        param_list = [dataset for dataset in f.values()[0] if not dataset == 'distances']
        fig, axes = plt.subplots(max(2,len(param_list)), max(2, len(f)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for i, sec_type in enumerate(f):
                for j, dataset in enumerate(param_list):
                    axes[j][i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:],
                                       label=description_list[index], color=colors[index])
                    axes[j][i].set_title(sec_type+' spines')
                    axes[j][i].set_xlabel('Distance from Soma (um)')
                    axes[j][i].set_ylabel(f.attrs['syn_type']+': '+dataset+'\n'+f.attrs[dataset])
                    axes[j][i].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_param_distribution(cell, syn_type, param_name):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified synaptic parameter for all spines. Used while
    debugging specification of synaptic parameters.
    :param cell: :class:'HocCell'
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        syn_list = []
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for spine in branch.spines:
                syn_list.extend(spine.synapses)
        for syn in [syn for syn in syn_list if syn_type in syn._syn]:
            distances.append(cell.get_distance_to_node(cell.tree.root, syn.node.parent.parent, syn.loc))
            if sec_type == 'basal':
                    distances[-1] *= -1
            param_vals.append(getattr(syn.target(syn_type), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.show()
    plt.close()
    print '# spines: ', len(cell.get_nodes_of_subtype('spine_head'))


def plot_mech_param_distribution(cell, mech_name, param_name):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_name: str
    :param param_name: str
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                distances.append(cell.get_distance_to_node(cell.tree.root, branch, seg.x))
                if sec_type == 'basal':
                    distances[-1] *= -1
                param_vals.append(getattr(getattr(seg, mech_name), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.show()
    plt.close()