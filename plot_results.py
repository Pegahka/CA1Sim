__author__ = 'milsteina'
from function_lib import *
import numpy as np


def plot_AR(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_spine_attenuation_ratio.
    Files contain voltage recordings from spine and branch probed with EPSC-shaped current injections to measure spine
    amplitude attenuation ratio, dendritic branch impedance, and spine neck resistance. Plots these parameters vs
    distance from dendrite origin, with one column per dendritic sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in [sim for sim in f.itervalues() if sim.attrs['stim_loc'] == 'spine']:
            rec = sim['rec']['0'] if sim['rec']['0'].attrs['description'] == 'branch' else sim['rec']['1']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    AR = {}
    dendR = {}
    neckR = {}
    fig, axes = plt.subplots(3, max(2, len(sec_types)))
    colors = ['k', 'r', 'b', 'g', 'c', 'm', 'y']
    for index, rec_filename in enumerate(rec_file_list):
        for sec_type in sec_types:
            distances[sec_type] = []
            AR[sec_type] = []
            dendR[sec_type] = []
            neckR[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0'].attrs['amp']
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            simiter = 0
            while simiter < len(f):
                if f[str(simiter)].attrs['stim_loc'] == 'spine':
                    spine_stim = f[str(simiter)]['rec']
                    spine_tvec = f[str(simiter)]['time']
                    branch_stim = f[str(simiter+1)]['rec']
                    branch_tvec = f[str(simiter+1)]['time']
                elif f[str(simiter)].attrs['stim_loc'] == 'branch':
                    spine_stim = f[str(simiter+1)]['rec']
                    spine_tvec = f[str(simiter+1)]['time']
                    branch_stim = f[str(simiter)]['rec']
                    branch_tvec = f[str(simiter)]['time']
                for rec in spine_stim.itervalues():
                    if rec.attrs['description'] == 'branch':
                        branch_rec = rec
                        sec_type = rec.attrs['type']
                    elif rec.attrs['description'] == 'spine':
                        spine_rec = rec
                distances[sec_type].append(branch_rec.attrs['branch_distance'])
                left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(branch_rec[left:right])
                baseline_spine = np.average(spine_rec[left:right])
                left, right = time2index(spine_tvec[:], equilibrate, duration)
                peak_branch = np.max(branch_rec[left:right]) - baseline_branch
                peak_spine = np.max(spine_rec[left:right]) - baseline_spine
                this_AR = peak_spine / peak_branch
                AR[sec_type].append(this_AR)
                branch_rec = branch_stim['0'] if branch_stim['0'].attrs['description'] == 'branch' else branch_stim['1']
                left, right = time2index(branch_tvec[:], equilibrate-3.0, equilibrate-1.0)
                baseline_branch = np.average(branch_rec[left:right])
                left, right = time2index(branch_tvec[:], equilibrate, duration)
                peak_branch = np.max(branch_rec[left:right]) - baseline_branch
                this_dendR = peak_branch / amp
                dendR[sec_type].append(this_dendR)
                this_neckR = (this_AR - 1) * this_dendR
                neckR[sec_type].append(this_neckR)
                simiter += 2
            for i, sec_type in enumerate(sec_types):
                axes[0][i].scatter(distances[sec_type], AR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[0][i].set_ylabel('Amplitude Ratio')
                axes[0][i].set_title(sec_type)
                axes[1][i].scatter(distances[sec_type], dendR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[1][i].set_ylabel('R_Dend (MOhm)')
                axes[1][i].set_title(sec_type)
                axes[2][i].scatter(distances[sec_type], neckR[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[2][i].set_ylabel('R_Neck (MOhm)')
                axes[2][i].set_title(sec_type)
    if not description_list == [""]:
        axes[0][0].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_spine_amp(rec_filename):
    """
    Plots a graph of spine EPSP amp and branch EPSP amp vs. distance from primary branch for each dendritic sec_type.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    spine_amp = {}
    branch_amp = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == 'spine':
            spine_stim = f[str(simiter)]['rec']
            spine_tvec = f[str(simiter)]['time']
        elif f[str(simiter)].attrs['stim_loc'] == 'branch':
            spine_stim = f[str(simiter+1)]['rec']
            spine_tvec = f[str(simiter+1)]['time']
        for rec in spine_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            spine_amp[sec_type] = []
            branch_amp[sec_type] = []
        distances[sec_type].append(branch_rec.attrs['branch_distance'])
        left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        baseline_spine = np.average(spine_rec[left:right])
        left, right = time2index(spine_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        peak_spine = np.max(spine_rec[left:right]) - baseline_spine
        spine_amp[sec_type].append(peak_spine)
        branch_amp[sec_type].append(peak_branch)
        simiter += 2
    fig, axes = plt.subplots(2, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(spine_amp[sec_type].__getitem__, indexes), marker='o',
                           color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Spine Amp (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(branch_amp[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('Branch Amp (mV)')
        axes[1][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_spine_Vm(rec_filename, stim_loc='spine'):
    """
    Plots traces from either spine or branch stim. Superimposes all traces from a dendritic sec type. Separates spine
    voltage from branch voltage.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    :param stim_loc: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    fig, axes = plt.subplots(2, 4)
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter)]['rec']
            tvec = f[str(simiter)]['time']
        elif f[str(simiter+1)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter+1)]['rec']
            tvec = f[str(simiter+1)]['time']
        for rec in stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
        left, right = time2index(tvec[:], equilibrate-5.0, duration)
        i = sec_types.index(sec_type)
        axes[0][i].plot(tvec[left:right], spine_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Spine Vm (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].plot(tvec[left:right], branch_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Branch Vm (mV)')
        axes[0][i].set_title(sec_type)
        simiter += 2
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_Rinp(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_rinp.
    Files contain voltage recordings from dendritic compartments probed with hyperpolarizing current injections to
    measure peak and steady-state input resistance, and their ratio. Plots these parameters vs distance from dendrite
    origin, with one column per dendritic sec_type.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_sec_types = ['basal', 'trunk', 'apical', 'tuft']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_sec_types = []
        for sim in f.itervalues():
            rec = sim['rec']['0']
            sec_type = rec.attrs['type']
            if not sec_type in temp_sec_types:
                temp_sec_types.append(sec_type)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    sec_types = [sec_type for sec_type in default_sec_types if sec_type in temp_sec_types]+\
                 [sec_type for sec_type in temp_sec_types if not sec_type in default_sec_types]
    distances = {}
    peak = {}
    steady = {}
    sag = {}
    fig, axes = plt.subplots(3, max(2, len(sec_types)))
    colors = ['k', 'r', 'b', 'g', 'c', 'm', 'y']
    for index, rec_filename in enumerate(rec_file_list):
        for sec_type in sec_types:
            distances[sec_type] = []
            peak[sec_type] = []
            steady[sec_type] = []
            sag[sec_type] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            amp = f['0']['stim']['0'].attrs['amp']
            start = f['0']['stim']['0'].attrs['delay']
            stop = start + f['0']['stim']['0'].attrs['dur']
            for sim in f.itervalues():
                rec = sim['rec']['0']
                sec_type = rec.attrs['type']
                distances[sec_type].append(rec.attrs['branch_distance'])
                tvec = sim['time']
                this_peak, this_steady = get_Rinp(tvec[:], rec[:], start, stop, amp)
                peak[sec_type].append(this_peak)
                steady[sec_type].append(this_steady)
                sag[sec_type].append(100*(1-this_steady/this_peak))
            for i, sec_type in enumerate(sec_types):
                color = colors[i]
                axes[0][i].scatter(distances[sec_type], peak[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[0][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[0][i].set_ylabel('Input Resistance - Peak (MOhm)')
                axes[0][i].set_title(sec_type)
                axes[1][i].scatter(distances[sec_type], steady[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[1][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[1][i].set_ylabel('Input Resistance - Steady-state (MOhm)')
                axes[1][i].set_title(sec_type)
                axes[2][i].scatter(distances[sec_type], sag[sec_type], label=description_list[index],
                                   color=colors[index])
                axes[2][i].set_xlabel('Distance from Dendrite Origin (um)')
                axes[2][i].set_ylabel('% Sag')
                axes[2][i].set_title(sec_type)
    if not description_list == [""]:
        axes[0][0].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_superimpose_conditions(rec_filename):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if 'description' in sim.attrs and not sim.attrs['description'] in sim_ids:
            sim_ids.append(sim.attrs['description'])
        for rec in sim['rec'].itervalues():
            if 'description' in rec.attrs:
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            if not rec_id in (id['id'] for id in rec_ids):
                rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    if len(rec_ids) > 1:
        fig, axes = plt.subplots(1, len(rec_ids))
    else:
        fig, ax = plt.subplots(1, 1)
        axes = [ax]
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for sim in f.itervalues():
        if 'description' in sim.attrs:
            sim_id = sim.attrs['description']
        else:
            sim_id = ''
        tvec = sim['time']
        for rec in sim['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    for i in range(len(rec_ids)):
        axes[i].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_attenuation(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces one figure containing a grid of 16 plots of EPSP amplitude vs. distance from dendrite origin.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    amps = {}
    fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'b', 'g', 'c', 'm', 'y']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            amps[input_loc] = {}
            for rec_loc in rec_locs:
                amps[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
                    baseline = np.average(rec[left:right])
                    left, right = time2index(tvec[:], equilibrate, duration)
                    amps[input_loc][rec_loc].append(np.max(rec[left:right]) - baseline)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes[i][j].scatter(distances[input_loc], amps[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Amp (mV)')
                    axes[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes[0][0].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_EPSP_kinetics(rec_file_list, description_list=""):
    """
    Expects each file in list to be generated by parallel_EPSP_attenuation.
    Files contain simultaneous voltage recordings from 4 locations (soma, trunk, branch, spine) during single spine
    stimulation. Spines are distributed across 4 dendritic sec_types (basal, trunk, apical, tuft).
    Produces a grid of 16 plots of EPSP kinetics vs. distance from dendrite origin.
    Produces one figure each for rise kinetics and decay kinetics.
    Superimposes results from multiple files in list.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if not type(description_list) == list:
        description_list = [description_list]
    default_input_locs = ['basal', 'trunk', 'apical', 'tuft']
    default_rec_locs = ['soma', 'trunk', 'branch', 'spine']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
            for rec in sim['rec'].itervalues():
                rec_loc = rec.attrs['description']
                if not rec_loc in temp_rec_locs:
                    temp_rec_locs.append(rec_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    rec_locs = [rec_loc for rec_loc in default_rec_locs if rec_loc in temp_rec_locs]+\
                 [rec_loc for rec_loc in temp_rec_locs if not rec_loc in default_rec_locs]
    distances = {}
    rise_taus = {}
    decay_taus = {}
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), max(2, len(rec_locs)))
    colors = ['k', 'r', 'b', 'g', 'c', 'm', 'y']
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
            for rec_loc in rec_locs:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            equilibrate = f['0'].attrs['equilibrate']
            duration = f['0'].attrs['duration']
            for sim in f.itervalues():
                tvec = sim['time']
                input_loc = sim.attrs['input_loc']
                distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
                for rec in sim['rec'].itervalues():
                    rec_loc = rec.attrs['description']
                    left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
                    interp_t = np.arange(0, duration, 0.001)
                    baseline = np.average(rec[left:right])
                    interp_vm = np.interp(interp_t, tvec[:], rec[:])
                    start, end = time2index(interp_t, equilibrate, duration)
                    interp_t = interp_t[start:end]
                    interp_vm = interp_vm[start:end] - baseline
                    amp = np.max(interp_vm)
                    t_peak = np.where(interp_vm == amp)[0][0]
                    interp_vm /= amp
                    interp_t -= interp_t[0]
                    rise_tau = optimize.curve_fit(model_exp_rise, interp_t[1:t_peak], interp_vm[1:t_peak], p0=0.3)[0]
                    decay_tau = optimize.curve_fit(model_exp_decay, interp_t[t_peak+1:]-interp_t[t_peak],
                                                   interp_vm[t_peak+1:], p0=5.)[0]
                    rise_taus[input_loc][rec_loc].append(rise_tau)
                    decay_taus[input_loc][rec_loc].append(decay_tau)
            for i, input_loc in enumerate(input_locs):
                for j, rec_loc in enumerate(rec_locs):
                    axes1[i][j].scatter(distances[input_loc], rise_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes1[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes1[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Rise Tau (ms)')
                    axes1[i][j].set_title('Recording Loc: '+rec_loc)
                    axes2[i][j].scatter(distances[input_loc], decay_taus[input_loc][rec_loc], color=colors[index],
                                        label=description_list[index])
                    axes2[i][j].set_xlabel('Distance from Dendrite Origin (um)')
                    axes2[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Decay Tau (ms)')
                    axes2[i][j].set_title('Recording Loc: '+rec_loc)
    if not description_list == [""]:
        axes1[0][0].legend(loc='best')
        axes2[0][0].legend(loc='best')
    fig1.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_parameter(rec_file_list, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if description_list is None:
        description_list = ["" for rec in rec_file_list]
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        param_list = [dataset for dataset in f.values()[0] if not dataset == 'distances']
        fig, axes = plt.subplots(max(2,len(param_list)), max(2, len(f)))
    colors = ['k', 'r', 'b', 'g', 'c', 'm', 'y']
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for i, sec_type in enumerate(f):
                for j, dataset in enumerate(param_list):
                    axes[j][i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:],
                                       label=description_list[index], color=colors[index])
                    axes[j][i].set_title(sec_type+' spines')
                    axes[j][i].set_xlabel('Distance from Soma (um)')
                    axes[j][i].set_ylabel(f.attrs['syn_type']+': '+dataset+'\n'+f.attrs[dataset])
                    axes[j][i].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_param_distribution(cell, syn_type, param_name):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified synaptic parameter for all spines. Used while
    debugging specification of synaptic parameters.
    :param cell: :class:'HocCell'
    """
    colors = ['r', 'b', 'g', 'c']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        syn_list = []
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for spine in branch.spines:
                syn_list.extend(spine.synapses)
        for syn in [syn for syn in syn_list if syn_type in syn._syn]:
            distances.append(cell.get_distance_to_node(cell.tree.root, syn.node.parent.parent, syn.loc))
            if sec_type == 'basal':
                    distances[-1] *= -1
            param_vals.append(getattr(syn.target(syn_type), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best')
    plt.show()
    plt.close()
    print '# spines: ', len(cell.get_nodes_of_subtype('spine_head'))


def plot_mech_param_distribution(cell, mech_name, param_name):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_name: str
    :param param_name: str
    """
    colors = ['r', 'b', 'g', 'c']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                distances.append(cell.get_distance_to_node(cell.tree.root, branch, seg.x))
                if sec_type == 'basal':
                    distances[-1] *= -1
                param_vals.append(getattr(getattr(seg, mech_name), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best')
    plt.show()
    plt.close()