__author__ = 'milsteina'
from function_lib import *
import numpy as np


def plot_AR(rec_filename):
    """
    Plots a graph of Amplitude Ratio (spine to branch) vs. distance from primary branch for each dendritic sec_type.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    AR = {}
    dendR = {}
    neckR = {}
    amp = f['0'].attrs['amp']
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == 'spine':
            spine_stim = f[str(simiter)]['rec']
            spine_tvec = f[str(simiter)]['time']
            branch_stim = f[str(simiter+1)]['rec']
            branch_tvec = f[str(simiter+1)]['time']
        elif f[str(simiter)].attrs['stim_loc'] == 'branch':
            spine_stim = f[str(simiter+1)]['rec']
            spine_tvec = f[str(simiter+1)]['time']
            branch_stim = f[str(simiter)]['rec']
            branch_tvec = f[str(simiter)]['time']
        for rec in spine_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            AR[sec_type] = []
            dendR[sec_type] = []
            neckR[sec_type] = []
        distances[sec_type].append(branch_rec.attrs['branch_distance'])
        left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        baseline_spine = np.average(spine_rec[left:right])
        left, right = time2index(spine_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        peak_spine = np.max(spine_rec[left:right]) - baseline_spine
        this_AR = peak_spine / peak_branch
        AR[sec_type].append(this_AR)
        for rec in branch_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                break
        left, right = time2index(branch_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        left, right = time2index(branch_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        this_dendR = peak_branch / amp
        dendR[sec_type].append(this_dendR)
        this_neckR = (this_AR - 1) * this_dendR
        neckR[sec_type].append(this_neckR)
        simiter += 2
    fig, axes = plt.subplots(3, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(AR[sec_type].__getitem__, indexes), marker='o', color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Amplitude Ratio')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(dendR[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('R_Dend (MOhm)')
        axes[1][i].set_title(sec_type)
        axes[2][i].scatter(sorted_distances[sec_type], map(neckR[sec_type].__getitem__, indexes), marker='v',
                                                                                            color=color)
        axes[2][i].set_xlabel('Location (um)')
        axes[2][i].set_ylabel('R_Neck (MOhm)')
        axes[2][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.5)
    plt.show()
    plt.close()
    f.close()


def plot_spine_amp(rec_filename):
    """
    Plots a graph of spine EPSP amp and branch EPSP amp vs. distance from primary branch for each dendritic sec_type.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    spine_amp = {}
    branch_amp = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == 'spine':
            spine_stim = f[str(simiter)]['rec']
            spine_tvec = f[str(simiter)]['time']
        elif f[str(simiter)].attrs['stim_loc'] == 'branch':
            spine_stim = f[str(simiter+1)]['rec']
            spine_tvec = f[str(simiter+1)]['time']
        for rec in spine_stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            spine_amp[sec_type] = []
            branch_amp[sec_type] = []
        distances[sec_type].append(branch_rec.attrs['branch_distance'])
        left, right = time2index(spine_tvec[:], equilibrate-3.0, equilibrate-1.0)
        baseline_branch = np.average(branch_rec[left:right])
        baseline_spine = np.average(spine_rec[left:right])
        left, right = time2index(spine_tvec[:], equilibrate, duration)
        peak_branch = np.max(branch_rec[left:right]) - baseline_branch
        peak_spine = np.max(spine_rec[left:right]) - baseline_spine
        spine_amp[sec_type].append(peak_spine)
        branch_amp[sec_type].append(peak_branch)
        simiter += 2
    fig, axes = plt.subplots(2, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(spine_amp[sec_type].__getitem__, indexes), marker='o',
                           color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Spine Amp (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(branch_amp[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('Branch Amp (mV)')
        axes[1][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_spine_Vm(rec_filename, stim_loc='spine'):
    """
    Plots traces from either spine or branch stim. Superimposes all traces from a dendritic sec type. Separates spine
    voltage from branch voltage.
    Expects .hdf5 files generated by test_spine_AR.py
    :param rec_filename: str
    :param stim_loc: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    fig, axes = plt.subplots(2, 4)
    simiter = 0
    while simiter < len(f):
        if f[str(simiter)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter)]['rec']
            tvec = f[str(simiter)]['time']
        elif f[str(simiter+1)].attrs['stim_loc'] == stim_loc:
            stim = f[str(simiter+1)]['rec']
            tvec = f[str(simiter+1)]['time']
        for rec in stim.itervalues():
            if rec.attrs['description'] == 'branch':
                branch_rec = rec
                sec_type = rec.attrs['type']
            elif rec.attrs['description'] == 'spine':
                spine_rec = rec
        if not sec_type in sec_types:
            sec_types.append(sec_type)
        left, right = time2index(tvec[:], equilibrate-5.0, duration)
        i = sec_types.index(sec_type)
        axes[0][i].plot(tvec[left:right], spine_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Spine Vm (mV)')
        axes[0][i].set_title(sec_type)
        axes[1][i].plot(tvec[left:right], branch_rec[left:right])
        axes[0][i].set_xlabel('Time (ms)')
        axes[0][i].set_ylabel('Branch Vm (mV)')
        axes[0][i].set_title(sec_type)
        simiter += 2
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_Rinp(rec_filename):
    """
    Produces a plot of input resistance vs. distance from primary branch for each dendritic subtype.
    Expects .hdf5 files generated by test_rinp.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    sec_types = []
    distances = {}
    peak = {}
    steady = {}
    sag = {}
    amp = f['0']['stim']['0'].attrs['amp']
    start = f['0']['stim']['0'].attrs['delay']
    stop = start + f['0']['stim']['0'].attrs['dur']
    for sim in f.itervalues():
        rec = sim['rec']['0']
        sec_type = rec.attrs['type']
        if not sec_type in sec_types:
            sec_types.append(sec_type)
            distances[sec_type] = []
            peak[sec_type] = []
            steady[sec_type] = []
            sag[sec_type] = []
        distances[sec_type].append(rec.attrs['branch_distance'])
        tvec = sim['time']
        this_peak, this_steady = get_Rinp(tvec[:], rec[:], start, stop, amp)
        peak[sec_type].append(this_peak)
        steady[sec_type].append(this_steady)
        sag[sec_type].append(100*(1-this_steady/this_peak))
    fig, axes = plt.subplots(3, len(sec_types))
    colors = ['b', 'g', 'r', 'c']
    sorted_distances = {}
    for i, sec_type in enumerate(sec_types):
        indexes = range(len(distances[sec_type]))
        indexes.sort(key=distances[sec_type].__getitem__)
        sorted_distances[sec_type] = map(distances[sec_type].__getitem__, indexes)
        color = colors[i]
        axes[0][i].scatter(sorted_distances[sec_type], map(peak[sec_type].__getitem__, indexes), marker='o',
                           color=color)
        axes[0][i].set_xlabel('Location (um)')
        axes[0][i].set_ylabel('Input Resistance - Peak (MOhm)')
        axes[0][i].set_title(sec_type)
        axes[1][i].scatter(sorted_distances[sec_type], map(steady[sec_type].__getitem__, indexes), marker='s',
                                                                                            color=color)
        axes[1][i].set_xlabel('Location (um)')
        axes[1][i].set_ylabel('Input Resistance - Steady-state (MOhm)')
        axes[1][i].set_title(sec_type)
        axes[2][i].scatter(sorted_distances[sec_type], map(sag[sec_type].__getitem__, indexes), marker='v',
                                                                                            color=color)
        axes[2][i].set_xlabel('Location (um)')
        axes[2][i].set_ylabel('% Sag')
        axes[2][i].set_title(sec_type)
    plt.subplots_adjust(hspace=0.3, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_superimpose_conditions(rec_filename):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if ('description' in sim.attrs) and not (sim.attrs['description'] in sim_ids):
            sim_ids.append(sim.attrs['description'])
    for rec in f['0']['rec'].itervalues():
        if ('description' in rec.attrs):
            rec_id = rec.attrs['description']
        else:
            rec_id = rec.attrs['type']+str(rec.attrs['index'])
        if not rec_id in (id['id'] for id in rec_ids):
            rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    if len(rec_ids) > 1:
        fig, axes = plt.subplots(1, len(rec_ids))
    else:
        fig, ax = plt.subplots(1, 1)
        axes = [ax]
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for simiter in f:
        if 'description' in f[simiter].attrs:
            sim_id = f[simiter].attrs['description']
        else:
            sim_id = ''
        tvec = f[simiter]['time']
        for rec in f[simiter]['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    for i in range(len(rec_ids)):
        axes[i].legend(loc='best')
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_attenuation(rec_filename):
    """
    Produces a grid of 12 plots of AMPAR EPSP amplitude vs. distance. Shows 4 recording locations (spine, branch, trunk,
    soma) for 4 spine locations (basal, trunk, apical, tuft).
    Expects .hdf5 files generated by test_EPSP_attenuation.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    input_locs = []
    rec_locs = []
    distances = {}
    sorted_distances = {}
    amps = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    for sim in f.itervalues():
        input_loc = sim.attrs['input_loc']
        if not input_loc in input_locs:
            input_locs.append(input_loc)
            distances[input_loc] = []
            amps[input_loc] = {}
        tvec = sim['time']
        distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
        for rec in sim['rec'].itervalues():
            rec_loc = rec.attrs['description']
            if not rec_loc in rec_locs:
                rec_locs.append(rec_loc)
            if not rec_loc in amps[input_loc]:
                amps[input_loc][rec_loc] = []
            left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
            baseline = np.average(rec[left:right])
            left, right = time2index(tvec[:], equilibrate, duration)
            amps[input_loc][rec_loc].append(np.max(rec[left:right]) - baseline)
    fig, axes = plt.subplots(max(2, len(input_locs)), len(rec_locs))
    colors = ['b', 'g', 'r', 'c']
    for i, input_loc in enumerate(input_locs):
        indexes = range(len(distances[input_loc]))
        indexes.sort(key=distances[input_loc].__getitem__)
        sorted_distances[input_loc] = map(distances[input_loc].__getitem__, indexes)
        for j, rec_loc in enumerate(rec_locs):
            color = colors[j]
            axes[i][j].scatter(sorted_distances[input_loc], map(amps[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes[i][j].set_xlabel('Location (um)')
            axes[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Amp (mV)')
            axes[i][j].set_title('Recording Loc: '+rec_loc)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_EPSP_kinetics(rec_filename):
    """
    Produces a grid of 12 plots of AMPAR EPSP kinetics vs. distance. Shows 4 recording locations (spine, branch, trunk,
    soma) for 4 spine locations (basal, trunk, apical, tuft).
    Produces one plot each for rise kinetics and decay kinetics.
    Expects .hdf5 files generated by test_EPSP_attenuation.py
    :param rec_filename: str
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    input_locs = []
    rec_locs = []
    distances = {}
    sorted_distances = {}
    rise_taus = {}
    decay_taus = {}
    equilibrate = f['0'].attrs['equilibrate']
    duration = f['0'].attrs['duration']
    for sim in f.itervalues():
        input_loc = sim.attrs['input_loc']
        if not input_loc in input_locs:
            input_locs.append(input_loc)
            distances[input_loc] = []
            rise_taus[input_loc] = {}
            decay_taus[input_loc] = {}
        tvec = sim['time']
        distances[input_loc].append(sim['rec']['3'].attrs['branch_distance'])
        for rec in sim['rec'].itervalues():
            rec_loc = rec.attrs['description']
            if not rec_loc in rec_locs:
                rec_locs.append(rec_loc)
            if not rec_loc in rise_taus[input_loc]:
                rise_taus[input_loc][rec_loc] = []
                decay_taus[input_loc][rec_loc] = []
            left, right = time2index(tvec[:], equilibrate-3.0, equilibrate-1.0)
            baseline = np.average(rec[left:right])
            left, right = time2index(tvec[:], equilibrate, duration)
            y = rec[left:right] - baseline
            t = tvec[left:right]
            t -= t[0]
            amp = np.max(y)
            y /= amp
            fit_amp, fit_rise, fit_decay = fit_exp_nonlinear(t, y, -5., -10.)
            rise_taus[input_loc][rec_loc].append(-1.*fit_rise)
            decay_taus[input_loc][rec_loc].append(-1*fit_decay)
    fig1, axes1 = plt.subplots(max(2, len(input_locs)), len(rec_locs))
    fig2, axes2 = plt.subplots(max(2, len(input_locs)), len(rec_locs))
    colors = ['b', 'g', 'r', 'c']
    for i, input_loc in enumerate(input_locs):
        indexes = range(len(distances[input_loc]))
        indexes.sort(key=distances[input_loc].__getitem__)
        sorted_distances[input_loc] = map(distances[input_loc].__getitem__, indexes)
        for j, rec_loc in enumerate(rec_locs):
            color = colors[j]
            axes1[i][j].scatter(sorted_distances[input_loc], map(rise_taus[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes1[i][j].set_xlabel('Location (um)')
            axes1[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Rise Tau (ms)')
            axes1[i][j].set_title('Recording Loc: '+rec_loc)
            axes2[i][j].scatter(sorted_distances[input_loc], map(decay_taus[input_loc][rec_loc].__getitem__, indexes),
                               color=color)
            axes2[i][j].set_xlabel('Location (um)')
            axes2[i][j].set_ylabel('Spine Location: '+input_loc+'\nEPSP Decay Tau (ms)')
            axes2[i][j].set_title('Recording Loc: '+rec_loc)
    fig1.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    fig2.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()
    f.close()


def plot_synaptic_parameter(rec_filename):
    """
    Expects file to contain dendritic locations and values of synaptic point_processs parameters, categorized by
    sec_type. Produces one scatter plot per sec_type, and superimposes all recorded parameters.
    :param rec_filename:
    """
    with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
        fig, axes = plt.subplots(1, max(2, len(f)))
        for i, sec_type in enumerate(f):
            for dataset in [dataset for dataset in f[sec_type] if not dataset == 'distance']:
                axes[i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:], label=f.attrs['syn_type'])
                axes[i].set_title(sec_type+' spines')
                axes[i].set_xlabel('Distance from Soma (um)')
                axes[i].set_ylabel(dataset+' - '+f.attrs[dataset])
                axes[i].legend(loc='best')
        plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.98, top=0.95, bottom=0.05)
        plt.show()
        plt.close()


def plot_gmax_distribution(cell):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and AMPA_KIN.gmax for all spines. Used while debugging specification
    of synaptic parameters.
    :param cell: :class:'HocCell'
    """
    colors = ['r', 'b', 'g', 'c']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        syn_list = []
        distances = []
        gmax_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for spine in branch.spines:
                syn_list.extend(spine.synapses)
        for syn in syn_list:
            distances.append(cell.get_distance_to_node(cell.tree.root, syn.node.parent.parent, syn.loc))
            gmax_vals.append(syn.target('AMPA_KIN').gmax)
        plt.scatter(distances, gmax_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best')
    plt.show()
    plt.close()

    print '# spines: ', len(cell.get_nodes_of_subtype('spine_head'))


def plot_mech_param_distribution(cell, mech_name, param_name):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_name: str
    :param param_name: str
    """
    colors = ['r', 'b', 'g', 'c']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                distances.append(cell.get_distance_to_node(cell.tree.root, branch, seg.x))
                param_vals.append(getattr(getattr(seg, mech_name), param_name))
        plt.scatter(distances, param_vals, color=colors[i], label=sec_type)
    plt.legend(loc='best')
    plt.show()
    plt.close()