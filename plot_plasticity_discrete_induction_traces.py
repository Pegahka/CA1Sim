__author__ = 'milsteina'
from plot_results import *
import matplotlib.gridspec as gridspec

"""
In this version of the simulation, phase precession of CA3 inputs is implemented using the method from Chadwick et al.,
Elife, 2015, which uses a circular gaussian with a phase sensitivity factor that effectively compresses the range of
phases within each theta cycle that each input is active, which will reduce jitter across within-cycle input sequences.

Here, the spine voltage and corresponding train of spikes that led to transitter release (successes) was recorded from
a simulation of a place field induction trial, with naive weights of 1 at all CA3 and ECIII inputs.

The plasticity signal traces are generated by using the mean kernel across all cells.

The global_kernel_scale and global_saturation_factor was estimated by running
optimize_discrete_long_plasticity_rule_032017 on cell 5 with the mean kernel.

"""

# input_filename = 'output120520161957-pid18137-seed0-e1600-i600-induction_spine_voltage0'
input_filename = 'output120720161451-pid48517-seed0-e1600-i600-induction_spine_voltage0'

peak_locs = {}
spine_vm = {}
spike_trains = {}
successes = {}
dt = 1.

with h5py.File(data_dir+input_filename+'.hdf5', 'r') as f:
    trial = f.itervalues().next()
    induction_run_vel = trial.attrs['run_vel']
    track_length = trial.attrs['track_length']
    stim_dt = trial.attrs['stim_dt']
    equilibrate = trial.attrs['equilibrate']
    track_equilibrate = trial.attrs['track_equilibrate']
    duration = trial.attrs['duration']
    track_duration = duration - equilibrate - track_equilibrate
    interp_t = np.arange(0., duration, dt)
    track_t = np.arange(0., track_duration, dt)
    start = int((equilibrate+track_equilibrate)/dt)
    t = trial['time'][:]
    dx = dt * induction_run_vel / 1000.
    interp_x = np.arange(0., len(track_t)*dx, dx)[:len(track_t)]
    for rec in trial['rec'].itervalues():
        if 'spine' in rec.attrs['description']:
            index = rec.attrs['index']
            vm = np.interp(interp_t, t, rec[:])[start:]
            spine_vm[index] = vm
        elif 'soma' in rec.attrs['description']:
            vm = np.interp(interp_t, t, rec[:])[start:]
            soma_vm = np.array(vm)
    for key in (key for key in trial['train'] if trial['train'][key].attrs['index'] in spine_vm.keys()):
        index = trial['train'][key].attrs['index']
        peak_locs[int(index)] = trial['train'][key].attrs['peak_loc']
        spike_trains[int(index)] = trial['train'][key][:]
        successes[int(index)] = trial['successes'][key][:]


field1_loc = 0.5
induction_dur = 300.


def build_kernels(x, plot=False):
    """
    Construct two kernels with exponential rise and decay:
    1) Local kernel that generates a plasticity signal at each spine
    2) Global kernal that generates a plasticity signal during dendritic calcium spiking
    :param x: array: [local_rise_tau, local_decay_tau, global_rise_tau, global_decay_tau, filter_ratio]
    :param plot: bool
    :return: array, array
    """
    local_rise_tau = x[0]
    local_decay_tau = x[1]
    global_rise_tau = x[2]
    global_decay_tau = x[3]

    max_time_scale = np.max([local_rise_tau+local_decay_tau, global_rise_tau+global_decay_tau])
    filter_t = np.arange(0., 6.*max_time_scale, dt)
    local_filter = np.exp(-filter_t/local_decay_tau) - np.exp(-filter_t/local_rise_tau)
    peak_index = np.where(local_filter == np.max(local_filter))[0][0]
    decay_indexes = np.where(local_filter[peak_index:] < 0.005*np.max(local_filter))[0]
    if np.any(decay_indexes):
        local_filter = local_filter[:peak_index+decay_indexes[0]]
    local_filter /= np.sum(local_filter)

    global_filter = np.exp(-filter_t / global_decay_tau) - np.exp(-filter_t / global_rise_tau)
    peak_index = np.where(global_filter == np.max(global_filter))[0][0]
    decay_indexes = np.where(global_filter[peak_index:] < 0.005 * np.max(global_filter))[0]
    if np.any(decay_indexes):
        global_filter = global_filter[:peak_index + decay_indexes[0]]
    global_filter /= np.sum(global_filter)

    if plot:
        fig, axes = plt.subplots(1)
        axes.plot(filter_t[:len(local_filter)]/1000., local_filter / np.max(local_filter), color='k',
                  label='Local plasticity kernel')
        axes.plot(filter_t[:len(global_filter)]/1000., global_filter / np.max(global_filter), color='b',
                  label='Global plasticity kernel')
        axes.legend(loc='best', frameon=False, framealpha=0.5)
        axes.set_xlabel('Time (s)')
        axes.set_ylabel('Kernel ampl. (norm.)')
        axes.set_xlim(-0.5, max(5000., max(filter_t[:len(local_filter)][-1], filter_t[:len(global_filter)][-1]))/1000.)
        clean_axes(axes)
        fig.tight_layout()
        plt.show()
        plt.close()

    return local_filter, global_filter


def plot_plasticity_signal_discrete(x, this_local_kernel, this_global_kernel, input_index):
    """
    Given the local and global kernels, convolve each input spike train (successes) with the local kernel, and convolve
    the current injection with the global kernel. Plot the resulting plasticity signals for a single induction trial.
    :param x: array
    "param input_index: int
    """
    filter_ratio = x[4]
    kernel_scale = global_kernel_scale
    saturation_factor = global_saturation_factor

    induction_gate = np.zeros_like(track_t)
    start_index = np.where(interp_x >= induction_loc)[0][0]
    end_index = start_index + int(induction_dur / dt)
    induction_gate[start_index:end_index] = 1.
    global_signal = np.convolve(induction_gate, this_global_kernel)[:len(track_t)] * kernel_scale
    spike_train = spike_trains[input_index]
    success_train = successes[input_index]
    indexes = (np.array(success_train)/dt).astype(int)
    this_stim_force = np.zeros_like(track_t)
    this_stim_force[indexes] = 1.
    local_signal = np.convolve(this_stim_force, this_local_kernel)[:len(track_t)] / saturation_factor * kernel_scale / \
                   filter_ratio
    this_signal = np.minimum(local_signal, global_signal)
    x_start = interp_t[start_index] / track_duration
    x_end = interp_t[end_index] / track_duration
    orig_font_size = mpl.rcParams['font.size']
    orig_fig_size = mpl.rcParams['figure.figsize']
    mpl.rcParams['font.size'] = 8.
    mpl.rcParams['figure.figsize'] = 6.0354, 3.5
    fig1 = plt.figure()
    gs1 = gridspec.GridSpec(2, 2)
    axes1 = plt.subplot(gs1[0, 0])
    ymax0 = -30.  # np.max(spine_vm[input_index])
    ymin0 = np.min(spine_vm[input_index])
    ydepth0 = ymax0 - ymin0
    ymax1 = np.max(global_signal)
    axes1.plot(track_t / 1000., spine_vm[input_index], label='Spine Vm', color='k', linewidth=0.5)
    axes1.scatter(spike_train / 1000., np.ones_like(spike_train) * (ymax0 + ydepth0 * 0.09), color='grey', s=20.,
                  alpha=0.5, linewidth=0, clip_on=False)
    axes1.scatter(success_train / 1000., np.ones_like(success_train) * (ymax0 - ydepth0 * 0.05), color='r', s=20.,
                  alpha=0.5, linewidth=0, clip_on=False)
    axes1.axhline(y=ymax0 + ydepth0 * 0.1, xmin=x_start, xmax=x_end, linewidth=1.5, c='k', clip_on=False)
    axes1.set_ylabel('Spine voltage (mV)')
    axes1.set_ylim((ymin0 - ydepth0 * 0.05), ymax0)
    axes1.set_xlim(0., track_duration / 1000.)
    clean_axes(axes1)

    axes2 = plt.subplot(gs1[0, 1])
    axes2.plot(track_t / 1000., global_signal, label='Global signal', color='b')
    axes2.plot(track_t / 1000., local_signal, label='Local signal', color='k')
    axes2.fill_between(track_t / 1000., 0., this_signal, label='Overlap', facecolor='grey', alpha=0.5)
    axes2.legend(loc='best', frameon=False, framealpha=0.5, handlelength=1, fontsize=mpl.rcParams['font.size'])
    axes2.set_xlabel('Time (s)')
    axes2.set_ylabel('Signal amplitude (a.u.)')
    axes2.set_xlim(0., track_duration/1000.)
    axes2.axhline(y=ymax1 * 1.1, xmin=x_start, xmax=x_end, linewidth=1.5, c='k', clip_on=False)
    axes2.set_ylim(0., ymax1*1.05)
    # axes.set_title('Induced plasticity signal')
    clean_axes(axes2)

    axes3 = plt.subplot(gs1[1, 0])
    ymax3 = np.max(soma_vm)  # -30.
    ymin3 = np.min(soma_vm)
    ydepth3 = ymax3 - ymin3
    axes3.plot(track_t / 1000., soma_vm, label='Soma Vm', color='k', linewidth=0.5)
    axes3.axhline(y=ymax3 + ydepth3 * 0.1, xmin=x_start, xmax=x_end, linewidth=1.5, c='k', clip_on=False)
    axes3.set_ylabel('Spine voltage (mV)')
    axes3.set_ylim((ymin3 - ydepth3 * 0.05), ymax3)
    axes3.set_xlim(0., track_duration / 1000.)
    clean_axes(axes3)

    gs1.tight_layout(fig1)
    plt.show()
    plt.close()


# to avoid saturation and reduce variability of time courses across cells, constrain the relative amplitude
# of global and local kernels:
# [local_rise_tau, local_decay_tau, global_rise_tau, global_decay_tau, filter_ratio]
x0 = {}

x0['long'] = [2.129E+02, 1.196E+03, 1.015E+02, 4.548E+02, 1.116E+00]  # Induced + Spontaneous 032117

global_kernel_scale = 1.995E-03
global_saturation_factor = 3.143E-02

induction_loc = field1_loc*track_length
local_kernel, global_kernel = {}, {}
for rule in x0:
    local_kernel[rule], global_kernel[rule] = build_kernels(x0[rule], plot=False)

# for input_index in spine_vm:
for input_index in [18662]:
    for rule in x0:
        plot_plasticity_signal_discrete(x0[rule], local_kernel[rule], global_kernel[rule], input_index)